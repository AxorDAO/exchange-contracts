{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/ownership/Ownable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "pragma solidity ^0.5.5;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following \n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n"
    },
    "contracts/external/chainlink/I_Aggregator.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\n\n/**\n * @title I_Aggregator\n * @author axor\n *\n * Partial interface for a Chainlink Aggregator.\n */\ninterface I_Aggregator {\n\n    // ============ Getter Functions ============\n\n    /**\n     * @notice Get the most recent answer from the aggregator.\n     * @dev Warning: Will return 0 if no answer has been reached.\n     */\n    function latestAnswer()\n        external\n        view\n        returns (int256);\n}\n"
    },
    "contracts/external/maker/I_MakerOracle.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\n\n/**\n * @title I_MakerOracle\n * @author axor\n *\n * Interface for the MakerDAO Oracles V2 smart contrats.\n */\ninterface I_MakerOracle {\n\n    // ============ Getter Functions ============\n\n    /**\n     * @notice Returns the current value as a bytes32.\n     */\n    function peek()\n        external\n        view\n        returns (bytes32, bool);\n\n    /**\n     * @notice Requires a fresh price and then returns the current value.\n     */\n    function read()\n        external\n        view\n        returns (bytes32);\n\n    /**\n     * @notice Returns the number of signers per poke.\n     */\n    function bar()\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns the timetamp of the last update.\n     */\n    function age()\n        external\n        view\n        returns (uint32);\n\n    /**\n     * @notice Returns 1 if the signer is authorized, and 0 otherwise.\n     */\n    function orcl(\n        address signer\n    )\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Returns 1 if the address is authorized to read the oracle price, and 0 otherwise.\n     */\n    function bud(\n        address reader\n    )\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice A mapping from the first byte of an authorized signer's address to the signer.\n     */\n    function slot(\n        uint8 signerId\n    )\n        external\n        view\n        returns (address);\n\n    // ============ State-Changing Functions ============\n\n    /**\n     * @notice Updates the value of the oracle\n     */\n    function poke(\n        uint256[] calldata val_,\n        uint256[] calldata age_,\n        uint8[] calldata v,\n        bytes32[] calldata r,\n        bytes32[] calldata s\n    )\n        external;\n\n    /**\n     * @notice Authorize an address to read the oracle price.\n     */\n    function kiss(\n        address reader\n    )\n        external;\n\n    /**\n     * @notice Unauthorize an address so it can no longer read the oracle price.\n     */\n    function diss(\n        address reader\n    )\n        external;\n\n    /**\n     * @notice Authorize addresses to read the oracle price.\n     */\n    function kiss(\n        address[] calldata readers\n    )\n        external;\n\n    /**\n     * @notice Unauthorize addresses so they can no longer read the oracle price.\n     */\n    function diss(\n        address[] calldata readers\n    )\n        external;\n}\n"
    },
    "contracts/protocol/lib/Adminable.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { Storage } from \"./Storage.sol\";\n\n\n/**\n * @title Adminable\n * @author axor\n *\n * @dev EIP-1967 Proxy Admin contract.\n */\ncontract Adminable {\n    /**\n     * @dev Storage slot with the admin of the contract.\n     *  This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    bytes32 internal constant ADMIN_SLOT =\n    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n    * @dev Modifier to check whether the `msg.sender` is the admin.\n    *  If it is, it will run the function. Otherwise, it will revert.\n    */\n    modifier onlyAdmin() {\n        require(\n            msg.sender == getAdmin(),\n            \"Adminable: caller is not admin\"\n        );\n        _;\n    }\n\n    /**\n     * @return The EIP-1967 proxy admin\n     */\n    function getAdmin()\n        public\n        view\n        returns (address)\n    {\n        return address(uint160(uint256(Storage.load(ADMIN_SLOT))));\n    }\n}\n"
    },
    "contracts/protocol/lib/BaseMath.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\n/**\n * @title BaseMath\n * @author axor\n *\n * @dev Arithmetic for fixed-point numbers with 18 decimals of precision.\n */\nlibrary BaseMath {\n    using SafeMath for uint256;\n\n    // The number One in the BaseMath system.\n    uint256 constant internal BASE = 10 ** 18;\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function base()\n        internal\n        pure\n        returns (uint256)\n    {\n        return BASE;\n    }\n\n    /**\n     * @dev Multiplies a value by a base value (result is rounded down).\n     */\n    function baseMul(\n        uint256 value,\n        uint256 baseValue\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return value.mul(baseValue).div(BASE);\n    }\n\n    /**\n     * @dev Multiplies a value by a base value (result is rounded down).\n     *  Intended as an alternaltive to baseMul to prevent overflow, when `value` is known\n     *  to be divisible by `BASE`.\n     */\n    function baseDivMul(\n        uint256 value,\n        uint256 baseValue\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return value.div(BASE).mul(baseValue);\n    }\n\n    /**\n     * @dev Multiplies a value by a base value (result is rounded up).\n     */\n    function baseMulRoundUp(\n        uint256 value,\n        uint256 baseValue\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        if (value == 0 || baseValue == 0) {\n            return 0;\n        }\n        return value.mul(baseValue).sub(1).div(BASE).add(1);\n    }\n\n    /**\n     * @dev Divide a value by a base value (result is rounded down).\n     */\n    function baseDiv(\n        uint256 value,\n        uint256 baseValue\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return value.mul(BASE).div(baseValue);\n    }\n\n    /**\n     * @dev Returns a base value representing the reciprocal of another base value (result is\n     *  rounded down).\n     */\n    function baseReciprocal(\n        uint256 baseValue\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return baseDiv(BASE, baseValue);\n    }\n}\n"
    },
    "contracts/protocol/lib/Math.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\n/**\n * @title Math\n * @author axor\n *\n * @dev Library for non-standard Math functions.\n */\nlibrary Math {\n    using SafeMath for uint256;\n\n    // ============ Library Functions ============\n\n    /**\n     * @dev Return target * (numerator / denominator), rounded down.\n     */\n    function getFraction(\n        uint256 target,\n        uint256 numerator,\n        uint256 denominator\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return target.mul(numerator).div(denominator);\n    }\n\n    /**\n     * @dev Return target * (numerator / denominator), rounded up.\n     */\n    function getFractionRoundUp(\n        uint256 target,\n        uint256 numerator,\n        uint256 denominator\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        if (target == 0 || numerator == 0) {\n            // SafeMath will check for zero denominator\n            return SafeMath.div(0, denominator);\n        }\n        return target.mul(numerator).sub(1).div(denominator).add(1);\n    }\n\n    /**\n     * @dev Returns the minimum between a and b.\n     */\n    function min(\n        uint256 a,\n        uint256 b\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the maximum between a and b.\n     */\n    function max(\n        uint256 a,\n        uint256 b\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return a > b ? a : b;\n    }\n}\n"
    },
    "contracts/protocol/lib/ReentrancyGuard.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\n\n/**\n * @title ReentrancyGuard\n * @author axor\n *\n * @dev Updated ReentrancyGuard library designed to be used with Proxy Contracts.\n */\ncontract ReentrancyGuard {\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = uint256(int256(-1));\n\n    uint256 private _STATUS_;\n\n    constructor () internal {\n        _STATUS_ = NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n        require(_STATUS_ != ENTERED, \"ReentrancyGuard: reentrant call\");\n        _STATUS_ = ENTERED;\n        _;\n        _STATUS_ = NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/protocol/lib/Require.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\n\n/**\n * @title Require\n * @author axor\n *\n * @dev Stringifies parameters to pretty-print revert messages.\n */\nlibrary Require {\n\n    // ============ Constants ============\n\n    uint256 constant ASCII_ZERO = 0x30; // '0'\n    uint256 constant ASCII_RELATIVE_ZERO = 0x57; // 'a' - 10\n    uint256 constant FOUR_BIT_MASK = 0xf;\n    bytes23 constant ZERO_ADDRESS =\n    0x3a20307830303030303030302e2e2e3030303030303030; // \": 0x00000000...00000000\"\n\n    // ============ Library Functions ============\n\n    /**\n     * @dev If the must condition is not true, reverts using a string combination of the reason and\n     *  the address.\n     */\n    function that(\n        bool must,\n        string memory reason,\n        address addr\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(string(abi.encodePacked(reason, stringify(addr))));\n        }\n    }\n\n    // ============ Helper Functions ============\n\n    /**\n     * @dev Returns a bytes array that is an ASCII string representation of the input address.\n     *  Returns \" 0x\", the first 4 bytes of the address in lowercase hex, \"...\", then the last 4\n     *  bytes of the address in lowercase hex.\n     */\n    function stringify(\n        address input\n    )\n        private\n        pure\n        returns (bytes memory)\n    {\n        // begin with \": 0x00000000...00000000\"\n        bytes memory result = abi.encodePacked(ZERO_ADDRESS);\n\n        // initialize values\n        uint256 z = uint256(input);\n        uint256 shift1 = 8 * 20 - 4;\n        uint256 shift2 = 8 * 4 - 4;\n\n        // populate both sections in parallel\n        for (uint256 i = 4; i < 12; i++) {\n            result[i] = char(z >> shift1); // set char in first section\n            result[i + 11] = char(z >> shift2); // set char in second section\n            shift1 -= 4;\n            shift2 -= 4;\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Returns the ASCII hex character representing the last four bits of the input (0-9a-f).\n     */\n    function char(\n        uint256 input\n    )\n        private\n        pure\n        returns (byte)\n    {\n        uint256 b = input & FOUR_BIT_MASK;\n        return byte(uint8(b + ((b < 10) ? ASCII_ZERO : ASCII_RELATIVE_ZERO)));\n    }\n}\n"
    },
    "contracts/protocol/lib/SafeCast.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\n\n/**\n * @title SafeCast\n * @author axor\n *\n * @dev Library for casting uint256 to other types of uint.\n */\nlibrary SafeCast {\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     *  overflow (i.e. when the input is greater than largest uint128).\n     *\n     *  Counterpart to Solidity's `uint128` operator.\n     *\n     *  Requirements:\n     *  - `value` must fit into 128 bits.\n     */\n    function toUint128(\n        uint256 value\n    )\n        internal\n        pure\n        returns (uint128)\n    {\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     *  overflow (i.e. when the input is greater than largest uint120).\n     *\n     *  Counterpart to Solidity's `uint120` operator.\n     *\n     *  Requirements:\n     *  - `value` must fit into 120 bits.\n     */\n    function toUint120(\n        uint256 value\n    )\n        internal\n        pure\n        returns (uint120)\n    {\n        require(value < 2**120, \"SafeCast: value doesn\\'t fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     *  overflow (i.e. when the input is greater than largest uint32).\n     *\n     *  Counterpart to Solidity's `uint32` operator.\n     *\n     *  Requirements:\n     *  - `value` must fit into 32 bits.\n     */\n    function toUint32(\n        uint256 value\n    )\n        internal\n        pure\n        returns (uint32)\n    {\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return uint32(value);\n    }\n}\n"
    },
    "contracts/protocol/lib/SignedMath.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\n/**\n * @title SignedMath\n * @author axor\n *\n * @dev SignedMath library for doing math with signed integers.\n */\nlibrary SignedMath {\n    using SafeMath for uint256;\n\n    // ============ Structs ============\n\n    struct Int {\n        uint256 value;\n        bool isPositive;\n    }\n\n    // ============ Functions ============\n\n    /**\n     * @dev Returns a new signed integer equal to a signed integer plus an unsigned integer.\n     */\n    function add(\n        Int memory sint,\n        uint256 value\n    )\n        internal\n        pure\n        returns (Int memory)\n    {\n        if (sint.isPositive) {\n            return Int({\n                value: value.add(sint.value),\n                isPositive: true\n            });\n        }\n        if (sint.value < value) {\n            return Int({\n                value: value.sub(sint.value),\n                isPositive: true\n            });\n        }\n        return Int({\n            value: sint.value.sub(value),\n            isPositive: false\n        });\n    }\n\n    /**\n     * @dev Returns a new signed integer equal to a signed integer minus an unsigned integer.\n     */\n    function sub(\n        Int memory sint,\n        uint256 value\n    )\n        internal\n        pure\n        returns (Int memory)\n    {\n        if (!sint.isPositive) {\n            return Int({\n                value: value.add(sint.value),\n                isPositive: false\n            });\n        }\n        if (sint.value > value) {\n            return Int({\n                value: sint.value.sub(value),\n                isPositive: true\n            });\n        }\n        return Int({\n            value: value.sub(sint.value),\n            isPositive: false\n        });\n    }\n\n    /**\n     * @dev Returns a new signed integer equal to a signed integer plus another signed integer.\n     */\n    function signedAdd(\n        Int memory augend,\n        Int memory addend\n    )\n        internal\n        pure\n        returns (Int memory)\n    {\n        return addend.isPositive\n            ? add(augend, addend.value)\n            : sub(augend, addend.value);\n    }\n\n    /**\n     * @dev Returns a new signed integer equal to a signed integer minus another signed integer.\n     */\n    function signedSub(\n        Int memory minuend,\n        Int memory subtrahend\n    )\n        internal\n        pure\n        returns (Int memory)\n    {\n        return subtrahend.isPositive\n            ? sub(minuend, subtrahend.value)\n            : add(minuend, subtrahend.value);\n    }\n\n    /**\n     * @dev Returns true if signed integer `a` is greater than signed integer `b`, false otherwise.\n     */\n    function gt(\n        Int memory a,\n        Int memory b\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        if (a.isPositive) {\n            if (b.isPositive) {\n                return a.value > b.value;\n            } else {\n                // True, unless both values are zero.\n                return a.value != 0 || b.value != 0;\n            }\n        } else {\n            if (b.isPositive) {\n                return false;\n            } else {\n                return a.value < b.value;\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the minimum of signed integers `a` and `b`.\n     */\n    function min(\n        Int memory a,\n        Int memory b\n    )\n        internal\n        pure\n        returns (Int memory)\n    {\n        return gt(b, a) ? a : b;\n    }\n\n    /**\n     * @dev Returns the maximum of signed integers `a` and `b`.\n     */\n    function max(\n        Int memory a,\n        Int memory b\n    )\n        internal\n        pure\n        returns (Int memory)\n    {\n        return gt(a, b) ? a : b;\n    }\n}\n"
    },
    "contracts/protocol/lib/Storage.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\n\n/**\n * @title Storage\n * @author axor\n *\n * @dev Storage library for reading/writing storage at a low level.\n */\nlibrary Storage {\n\n    /**\n     * @dev Performs an SLOAD and returns the data in the slot.\n     */\n    function load(\n        bytes32 slot\n    )\n        internal\n        view\n        returns (bytes32)\n    {\n        bytes32 result;\n        /* solium-disable-next-line security/no-inline-assembly */\n        assembly {\n            result := sload(slot)\n        }\n        return result;\n    }\n\n    /**\n     * @dev Performs an SSTORE to save the value to the slot.\n     */\n    function store(\n        bytes32 slot,\n        bytes32 value\n    )\n        internal\n    {\n        /* solium-disable-next-line security/no-inline-assembly */\n        assembly {\n            sstore(slot, value)\n        }\n    }\n}\n"
    },
    "contracts/protocol/lib/TypedSignature.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\n\n/**\n * @title TypedSignature\n * @author axor\n *\n * @dev Library to unparse typed signatures.\n */\nlibrary TypedSignature {\n\n    // ============ Constants ============\n\n    bytes32 constant private FILE = \"TypedSignature\";\n\n    // Prepended message with the length of the signed hash in decimal.\n    bytes constant private PREPEND_DEC = \"\\x19Ethereum Signed Message:\\n32\";\n\n    // Prepended message with the length of the signed hash in hexadecimal.\n    bytes constant private PREPEND_HEX = \"\\x19Ethereum Signed Message:\\n\\x20\";\n\n    // Number of bytes in a typed signature.\n    uint256 constant private NUM_SIGNATURE_BYTES = 66;\n\n    // ============ Enums ============\n\n    // Different RPC providers may implement signing methods differently, so we allow different\n    // signature types depending on the string prepended to a hash before it was signed.\n    enum SignatureType {\n        NoPrepend,   // No string was prepended.\n        Decimal,     // PREPEND_DEC was prepended.\n        Hexadecimal, // PREPEND_HEX was prepended.\n        Invalid      // Not a valid type. Used for bound-checking.\n    }\n\n    // ============ Structs ============\n\n    struct Signature {\n        bytes32 r;\n        bytes32 s;\n        bytes2 vType;\n    }\n\n    // ============ Functions ============\n\n    /**\n     * @dev Gives the address of the signer of a hash. Also allows for the commonly prepended string\n     *  of '\\x19Ethereum Signed Message:\\n' + message.length\n     *\n     * @param  hash       Hash that was signed (does not include prepended message).\n     * @param  signature  Type and ECDSA signature with structure: {32:r}{32:s}{1:v}{1:type}\n     * @return            Address of the signer of the hash.\n     */\n    function recover(\n        bytes32 hash,\n        Signature memory signature\n    )\n        internal\n        pure\n        returns (address)\n    {\n        SignatureType sigType = SignatureType(uint8(bytes1(signature.vType << 8)));\n\n        bytes32 signedHash;\n        if (sigType == SignatureType.NoPrepend) {\n            signedHash = hash;\n        } else if (sigType == SignatureType.Decimal) {\n            signedHash = keccak256(abi.encodePacked(PREPEND_DEC, hash));\n        } else {\n            assert(sigType == SignatureType.Hexadecimal);\n            signedHash = keccak256(abi.encodePacked(PREPEND_HEX, hash));\n        }\n\n        return ecrecover(\n            signedHash,\n            uint8(bytes1(signature.vType)),\n            signature.r,\n            signature.s\n        );\n    }\n}\n"
    },
    "contracts/protocol/v1/impl/P1Admin.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { P1FinalSettlement } from \"./P1FinalSettlement.sol\";\nimport { P1Storage } from \"./P1Storage.sol\";\nimport { BaseMath } from \"../../lib/BaseMath.sol\";\nimport { I_P1Funder } from \"../intf/I_P1Funder.sol\";\nimport { I_P1Oracle } from \"../intf/I_P1Oracle.sol\";\nimport { P1Types } from \"../lib/P1Types.sol\";\n\n\n/**\n * @title P1Admin\n * @author axor\n *\n * @notice Contract allowing the Admin address to set certain parameters.\n */\ncontract P1Admin is\n    P1Storage,\n    P1FinalSettlement\n{\n    // ============ Events ============\n\n    event LogSetGlobalOperator(\n        address operator,\n        bool approved\n    );\n\n    event LogSetOracle(\n        address oracle\n    );\n\n    event LogSetFunder(\n        address funder\n    );\n\n    event LogSetMinCollateral(\n        uint256 minCollateral\n    );\n\n    event LogFinalSettlementEnabled(\n        uint256 settlementPrice\n    );\n\n    // ============ Functions ============\n\n    /**\n     * @notice Add or remove a Global Operator address.\n     * @dev Must be called by the PerpetualV1 admin. Emits the LogSetGlobalOperator event.\n     *\n     * @param  operator  The address for which to enable or disable global operator privileges.\n     * @param  approved  True if approved, false if disapproved.\n     */\n    function setGlobalOperator(\n        address operator,\n        bool approved\n    )\n        external\n        onlyAdmin\n        nonReentrant\n    {\n        _GLOBAL_OPERATORS_[operator] = approved;\n        emit LogSetGlobalOperator(operator, approved);\n    }\n\n    /**\n     * @notice Sets a new price oracle contract.\n     * @dev Must be called by the PerpetualV1 admin. Emits the LogSetOracle event.\n     *\n     * @param  oracle  The address of the new price oracle contract.\n     */\n    function setOracle(\n        address oracle\n    )\n        external\n        onlyAdmin\n        nonReentrant\n    {\n        require(\n            I_P1Oracle(oracle).getPrice() != 0,\n            \"New oracle cannot return a zero price\"\n        );\n        _ORACLE_ = oracle;\n        emit LogSetOracle(oracle);\n    }\n\n    /**\n     * @notice Sets a new funder contract.\n     * @dev Must be called by the PerpetualV1 admin. Emits the LogSetFunder event.\n     *\n     * @param  funder  The address of the new funder contract.\n     */\n    function setFunder(\n        address funder\n    )\n        external\n        onlyAdmin\n        nonReentrant\n    {\n        // call getFunding to ensure that no reverts occur\n        I_P1Funder(funder).getFunding(0);\n\n        _FUNDER_ = funder;\n        emit LogSetFunder(funder);\n    }\n\n    /**\n     * @notice Sets a new value for the minimum collateralization percentage.\n     * @dev Must be called by the PerpetualV1 admin. Emits the LogSetMinCollateral event.\n     *\n     * @param  minCollateral  The new value of the minimum initial collateralization percentage,\n     *                        as a fixed-point number with 18 decimals.\n     */\n    function setMinCollateral(\n        uint256 minCollateral\n    )\n        external\n        onlyAdmin\n        nonReentrant\n    {\n        require(\n            minCollateral >= BaseMath.base(),\n            \"The collateral requirement cannot be under 100%\"\n        );\n        _MIN_COLLATERAL_ = minCollateral;\n        emit LogSetMinCollateral(minCollateral);\n    }\n\n    /**\n     * @notice Sets a new value for the number of blocks required to withdraw funds.\n     * @dev Must be called by the PerpetualV1 admin.\n     *\n     * @param  withdrawDelayBlock  The new value of the number of blocks required to withdraw funds.\n     */\n    function setWithdrawDelayBlock(\n        uint256 withdrawDelayBlock\n    )\n        external\n        onlyAdmin\n        nonReentrant\n    {\n        _WITHDRAW_DELAY_BLOCK_ = withdrawDelayBlock;\n    }\n\n    /**\n     * @notice Enables final settlement if the oracle price is between the provided bounds.\n     * @dev Must be called by the PerpetualV1 admin. The current result of the price oracle\n     *  must be between the two bounds supplied. Emits the LogFinalSettlementEnabled event.\n     *\n     * @param  priceLowerBound  The lower-bound (inclusive) of the acceptable price range.\n     * @param  priceUpperBound  The upper-bound (inclusive) of the acceptable price range.\n     */\n    function enableFinalSettlement(\n        uint256 priceLowerBound,\n        uint256 priceUpperBound\n    )\n        external\n        onlyAdmin\n        noFinalSettlement\n        nonReentrant\n    {\n        // Update the Global Index and grab the Price.\n        P1Types.Context memory context = _loadContext();\n\n        // Check price bounds.\n        require(\n            context.price >= priceLowerBound,\n            \"Oracle price is less than the provided lower bound\"\n        );\n        require(\n            context.price <= priceUpperBound,\n            \"Oracle price is greater than the provided upper bound\"\n        );\n\n        // Save storage variables.\n        _FINAL_SETTLEMENT_PRICE_ = context.price;\n        _FINAL_SETTLEMENT_ENABLED_ = true;\n\n        emit LogFinalSettlementEnabled(_FINAL_SETTLEMENT_PRICE_);\n    }\n}\n"
    },
    "contracts/protocol/v1/impl/P1FinalSettlement.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport { P1Settlement } from \"./P1Settlement.sol\";\nimport { BaseMath } from \"../../lib/BaseMath.sol\";\nimport { Math } from \"../../lib/Math.sol\";\nimport { P1BalanceMath } from \"../lib/P1BalanceMath.sol\";\nimport { P1Types } from \"../lib/P1Types.sol\";\n\n\n/**\n * @title P1FinalSettlement\n * @author axor\n *\n * @notice Functions regulating the smart contract's behavior during final settlement.\n */\ncontract P1FinalSettlement is\n    P1Settlement\n{\n    using SafeMath for uint256;\n\n    // ============ Events ============\n\n    event LogWithdrawFinalSettlement(\n        address indexed account,\n        uint256 amount,\n        bytes32 balance\n    );\n\n    // ============ Modifiers ============\n\n    /**\n    * @dev Modifier to ensure the function is not run after final settlement has been enabled.\n    */\n    modifier noFinalSettlement() {\n        require(\n            !_FINAL_SETTLEMENT_ENABLED_,\n            \"Not permitted during final settlement\"\n        );\n        _;\n    }\n\n    /**\n    * @dev Modifier to ensure the function is only run after final settlement has been enabled.\n    */\n    modifier onlyFinalSettlement() {\n        require(\n            _FINAL_SETTLEMENT_ENABLED_,\n            \"Only permitted during final settlement\"\n        );\n        _;\n    }\n\n    // ============ Functions ============\n\n    /**\n     * @notice Withdraw the number of margin tokens equal to the value of the account at the time\n     *  that final settlement occurred.\n     * @dev Emits the LogAccountSettled and LogWithdrawFinalSettlement events.\n     */\n    function withdrawFinalSettlement()\n        external\n        onlyFinalSettlement\n        nonReentrant\n    {\n        // Load the context using the final settlement price.\n        P1Types.Context memory context = P1Types.Context({\n            price: _FINAL_SETTLEMENT_PRICE_,\n            minCollateral: _MIN_COLLATERAL_,\n            index: _GLOBAL_INDEX_\n        });\n\n        // Apply funding changes.\n        (P1Types.Balance memory balance,,) = _settleAccountWhenUserForceWithdraw(context, msg.sender);\n\n        // Determine the account net value.\n        // `positive` and `negative` are base values with extra precision.\n        (uint256 positive, uint256 negative) = P1BalanceMath.getPositiveAndNegativeValue(\n            balance,\n            context.price\n        );\n\n        // No amount is withdrawable.\n        if (positive < negative) {\n            return;\n        }\n\n        // Get the account value, which is rounded down to the nearest token amount.\n        uint256 accountValue = positive.sub(negative).div(BaseMath.base());\n\n        // Get the number of tokens in the Perpetual Contract.\n        uint256 contractBalance = IERC20(_TOKEN_).balanceOf(address(this));\n\n        // Determine the maximum withdrawable amount.\n        uint256 amountToWithdraw = Math.min(contractBalance, accountValue);\n\n        // Update the user's balance.\n        uint120 remainingMargin = accountValue.sub(amountToWithdraw).toUint120();\n        balance = P1Types.Balance({\n            marginIsPositive: remainingMargin != 0,\n            positionIsPositive: false,\n            margin: remainingMargin,\n            position: 0\n        });\n        _BALANCES_[msg.sender] = balance;\n\n        // Send the tokens.\n        SafeERC20.safeTransfer(\n            IERC20(_TOKEN_),\n            msg.sender,\n            amountToWithdraw\n        );\n\n        // Emit the log.\n        emit LogWithdrawFinalSettlement(\n            msg.sender,\n            amountToWithdraw,\n            balance.toBytes32()\n        );\n    }\n}\n"
    },
    "contracts/protocol/v1/impl/P1Getters.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { P1Storage } from \"./P1Storage.sol\";\nimport { I_P1Oracle } from \"../intf/I_P1Oracle.sol\";\nimport { P1Types } from \"../lib/P1Types.sol\";\n\n\n/**\n * @title P1Getters\n * @author axor\n *\n * @notice Contract for read-only getters.\n */\ncontract P1Getters is\n    P1Storage\n{\n    // ============ Account Getters ============\n\n    /**\n     * @notice Get the balance of an account, without accounting for changes in the index.\n     *\n     * @param  account  The address of the account to query the balances of.\n     * @return          The balances of the account.\n     */\n    function getAccountBalance(\n        address account\n    )\n        external\n        view\n        returns (P1Types.Balance memory)\n    {\n        return _BALANCES_[account];\n    }\n\n    /**\n     * @notice Gets the most recently cached index of an account.\n     *\n     * @param  account  The address of the account to query the index of.\n     * @return          The index of the account.\n     */\n    function getAccountIndex(\n        address account\n    )\n        external\n        view\n        returns (P1Types.Index memory)\n    {\n        return _LOCAL_INDEXES_[account];\n    }\n\n    /**\n     * @notice Gets the local operator status of an operator for a particular account.\n     *\n     * @param  account   The account to query the operator for.\n     * @param  operator  The address of the operator to query the status of.\n     * @return           True if the operator is a local operator of the account, false otherwise.\n     */\n    function getIsLocalOperator(\n        address account,\n        address operator\n    )\n        external\n        view\n        returns (bool)\n    {\n        return _LOCAL_OPERATORS_[account][operator];\n    }\n\n    // ============ Global Getters ============\n\n    /**\n     * @notice Gets the global operator status of an address.\n     *\n     * @param  operator  The address of the operator to query the status of.\n     * @return           True if the address is a global operator, false otherwise.\n     */\n    function getIsGlobalOperator(\n        address operator\n    )\n        external\n        view\n        returns (bool)\n    {\n        return _GLOBAL_OPERATORS_[operator];\n    }\n\n    /**\n     * @notice Gets the address of the ERC20 margin contract used for margin deposits.\n     *\n     * @return The address of the ERC20 token.\n     */\n    function getTokenContract()\n        external\n        view\n        returns (address)\n    {\n        return _TOKEN_;\n    }\n\n    /**\n     * @notice Gets the current address of the price oracle contract.\n     *\n     * @return The address of the price oracle contract.\n     */\n    function getOracleContract()\n        external\n        view\n        returns (address)\n    {\n        return _ORACLE_;\n    }\n\n    /**\n     * @notice Gets the current address of the funder contract.\n     *\n     * @return The address of the funder contract.\n     */\n    function getFunderContract()\n        external\n        view\n        returns (address)\n    {\n        return _FUNDER_;\n    }\n\n    /**\n     * @notice Gets the most recently cached global index.\n     *\n     * @return The most recently cached global index.\n     */\n    function getGlobalIndex()\n        external\n        view\n        returns (P1Types.Index memory)\n    {\n        return _GLOBAL_INDEX_;\n    }\n\n    /**\n     * @notice Gets minimum collateralization ratio of the protocol.\n     *\n     * @return The minimum-acceptable collateralization ratio, returned as a fixed-point number with\n     *  18 decimals of precision.\n     */\n    function getMinCollateral()\n        external\n        view\n        returns (uint256)\n    {\n        return _MIN_COLLATERAL_;\n    }\n\n\n    function getDelayBlock()\n        external\n        view\n        returns (uint256)\n    {\n        return _WITHDRAW_DELAY_BLOCK_;\n    }\n\n    function getUserFlag(address account)\n        external\n        view\n        returns (uint256)\n    {\n        return _WITHDRAW_DELAY_[account];\n    }\n\n    /**\n     * @notice Gets the status of whether final-settlement was initiated by the Admin.\n     *\n     * @return True if final-settlement was enabled, false otherwise.\n     */\n    function getFinalSettlementEnabled()\n        external\n        view\n        returns (bool)\n    {\n        return _FINAL_SETTLEMENT_ENABLED_;\n    }\n\n    // ============ Authorized External Getters ============\n\n    /**\n     * @notice Gets the price returned by the oracle.\n     * @dev Only able to be called by global operators.\n     *\n     * @return The price returned by the current price oracle.\n     */\n    function getOraclePrice()\n        external\n        view\n        returns (uint256)\n    {\n        require(\n            _GLOBAL_OPERATORS_[msg.sender],\n            \"Oracle price requester not global operator\"\n        );\n        return I_P1Oracle(_ORACLE_).getPrice();\n    }\n\n    // ============ Public Getters ============\n\n    /**\n     * @notice Gets whether an address has permissions to operate an account.\n     *\n     * @param  account   The account to query.\n     * @param  operator  The address to query.\n     * @return           True if the operator has permission to operate the account,\n     *                   and false otherwise.\n     */\n    function hasAccountPermissions(\n        address account,\n        address operator\n    )\n        public\n        view\n        returns (bool)\n    {\n        return account == operator\n            || _GLOBAL_OPERATORS_[operator]\n            || _LOCAL_OPERATORS_[account][operator];\n    }\n}\n"
    },
    "contracts/protocol/v1/impl/P1Margin.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport { P1FinalSettlement } from \"./P1FinalSettlement.sol\";\nimport { P1Getters } from \"./P1Getters.sol\";\nimport { P1BalanceMath } from \"../lib/P1BalanceMath.sol\";\nimport { P1Types } from \"../lib/P1Types.sol\";\n\n/**\n * @title P1Margin\n * @author axor\n *\n * @notice Contract for withdrawing and depositing.\n */\ncontract P1Margin is\n    P1FinalSettlement,\n    P1Getters\n{\n    using P1BalanceMath for P1Types.Balance;\n\n    // ============ Events ============\n\n    event LogDeposit(\n        address indexed account,\n        uint256 amount,\n        bytes32 balance\n    );\n\n    event LogWithdraw(\n        address indexed account,\n        address destination,\n        uint256 amount,\n        bytes32 balance\n    );\n\n    event LogUserForceWithdraw(\n        address indexed account,\n        address destination,\n        uint256 amount,\n        bool settlementIsPositive,\n        uint256 settlementAmount,\n        bytes32 balance\n    );\n\n    event LogSetWithdraw(\n        address indexed account,\n        address destination\n    );\n\n    // ============ Functions ============\n\n    /**\n     * @notice Deposit some amount of margin tokens from the msg.sender into an account.\n     * @dev Emits LogIndex, LogAccountSettled, and LogDeposit events.\n     *\n     * @param  account  The account for which to credit the deposit.\n     * @param  amount   the amount of tokens to deposit.\n     */\n    function deposit(\n        address from,\n        address account,\n        uint256 amount,\n        uint256 price,\n        uint256 settlementAmounts,\n        bool settlementIsPositives\n    )\n        external\n        noFinalSettlement\n        nonReentrant\n    {\n        require(\n            _GLOBAL_OPERATORS_[msg.sender],\n            \"trader is not global operator\"\n        );\n        P1Types.Context memory context = _loadContextWithPrice(price);\n        P1Types.Balance memory balance = _settleAccount(context, account, settlementAmounts, settlementIsPositives);\n\n        SafeERC20.safeTransferFrom(\n            IERC20(_TOKEN_),\n            from,\n            address(this),\n            amount\n        );\n\n        balance.addToMargin(amount);\n        _BALANCES_[account] = balance;\n\n        emit LogDeposit(\n            account,\n            amount,\n            balance.toBytes32()\n        );\n    }\n\n    /**\n     * @notice Set Withdraw acction.\n     * @dev Emits LogIndex, LogAccountSettled, and LogWithdraw events.\n     *\n     * @param  account      The account for which to debit the withdrawal.\n     * @param  destination  The address to which the tokens are transferred.\n     */\n    function requestWithdraw(\n        address account,\n        address destination\n    )\n        external\n        noFinalSettlement\n        nonReentrant\n    {\n        require(\n            hasAccountPermissions(account, msg.sender),\n            \"sender does not have permission to withdraw\"\n        );\n\n        _WITHDRAW_DELAY_[account] = block.number;\n\n        emit LogSetWithdraw(\n            account,\n            destination\n        );\n    }\n\n    /**\n     * @notice Withdraw some amount of margin tokens from an account to a destination address.\n     * @dev Emits LogIndex, LogAccountSettled, and LogWithdraw events.\n     *\n     * @param  account      The account for which to debit the withdrawal.\n     * @param  destination  The address to which the tokens are transferred.\n     * @param  amount       The amount of tokens to withdraw.\n     * @param  price        The oracle price at the time of the withdrawal.\n     */\n    function withdraw(\n        address account,\n        address destination,\n        uint256 amount,\n        uint256 price,\n        uint256 settlementAmounts,\n        bool settlementIsPositives\n    )\n        external\n        noFinalSettlement\n        nonReentrant\n    {\n        require(\n            _GLOBAL_OPERATORS_[msg.sender],\n            \"only global operator can withdraw\"\n        );\n\n        P1Types.Context memory context = _loadContextWithPrice(price);\n        P1Types.Balance memory balance = _settleAccount(context, account, settlementAmounts, settlementIsPositives);\n        _WITHDRAW_DELAY_[account] = 0;\n        \n        SafeERC20.safeTransfer(\n            IERC20(_TOKEN_),\n            destination,\n            amount\n        );\n\n        balance.subFromMargin(amount);\n        _BALANCES_[account] = balance;\n\n        require(\n            _isCollateralized(context, balance),\n            \"account not collateralized\"\n        );\n\n        emit LogWithdraw(\n            account,\n            destination,\n            amount,\n            balance.toBytes32()\n        );\n    }\n\n    /**\n     * @notice Withdraw some amount of margin tokens from an account to a destination address.\n     * @dev Emits LogIndex, LogAccountSettled, and LogWithdraw events.\n     *\n     * @param  account      The account for which to debit the withdrawal.\n     * @param  destination  The address to which the tokens are transferred.\n     * @param  amount       The amount of tokens to withdraw.\n     */\n    function userWithdraw(\n        address account,\n        address destination,\n        uint256 amount\n    )\n        external\n        noFinalSettlement\n        nonReentrant\n    {\n        require(\n            hasAccountPermissions(account, msg.sender),\n            \"sender does not have permission to withdraw\"\n        );\n        require(\n            (\n                _WITHDRAW_DELAY_[account] > 0 &&\n                _WITHDRAW_DELAY_[account] + _WITHDRAW_DELAY_BLOCK_ <= block.number\n            ),\n            \"cannot withdraw\"\n        );\n\n        _WITHDRAW_DELAY_[account] = 0;\n\n        P1Types.Context memory context = _loadContext();\n        (P1Types.Balance memory balance, bool settlementIsPositive, uint256 settlementAmount) = _settleAccountWhenUserForceWithdraw(context, account);\n\n        // require(\n        //     amount >= settlementAmount,\n        //     \"insufficient balance to cover funding fee\"\n        // );\n        // if (settlementIsPositive) {\n        //     amount -= settlementAmount;\n        // } else {\n        //     amount += settlementAmount;\n        // }\n        SafeERC20.safeTransfer(\n            IERC20(_TOKEN_),\n            destination,\n            amount\n        );\n\n        balance.subFromMargin(amount);\n        _BALANCES_[account] = balance;\n\n        require(\n            _isCollateralized(context, balance),\n            \"account not collateralized\"\n        );\n\n        emit LogUserForceWithdraw(\n            account,\n            destination,\n            amount,\n            settlementIsPositive,\n            settlementAmount,\n            balance.toBytes32()\n        );\n    }\n}\n"
    },
    "contracts/protocol/v1/impl/P1Operator.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { P1Storage } from \"./P1Storage.sol\";\n\n\n/**\n * @title P1Operator\n * @author axor\n *\n * @notice Contract for setting local operators for an account.\n */\ncontract P1Operator is\n    P1Storage\n{\n    // ============ Events ============\n\n    event LogSetLocalOperator(\n        address indexed sender,\n        address operator,\n        bool approved\n    );\n\n    // ============ Functions ============\n\n    /**\n     * @notice Grants or revokes permission for another account to perform certain actions on behalf\n     *  of the sender.\n     * @dev Emits the LogSetLocalOperator event.\n     *\n     * @param  operator  The account that is approved or disapproved.\n     * @param  approved  True for approval, false for disapproval.\n     */\n    function setLocalOperator(\n        address operator,\n        bool approved\n    )\n        external\n    {\n        _LOCAL_OPERATORS_[msg.sender][operator] = approved;\n        emit LogSetLocalOperator(msg.sender, operator, approved);\n    }\n}\n"
    },
    "contracts/protocol/v1/impl/P1Settlement.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { P1Storage } from \"./P1Storage.sol\";\nimport { BaseMath } from \"../../lib/BaseMath.sol\";\nimport { SafeCast } from \"../../lib/SafeCast.sol\";\nimport { SignedMath } from \"../../lib/SignedMath.sol\";\nimport { I_P1Funder } from \"../intf/I_P1Funder.sol\";\nimport { I_P1Oracle } from \"../intf/I_P1Oracle.sol\";\nimport { P1BalanceMath } from \"../lib/P1BalanceMath.sol\";\nimport { P1IndexMath } from \"../lib/P1IndexMath.sol\";\nimport { P1Types } from \"../lib/P1Types.sol\";\n\n\n/**\n * @title P1Settlement\n * @author axor\n *\n * @notice Contract containing logic for settling funding payments between accounts.\n */\ncontract P1Settlement is\n    P1Storage\n{\n    using BaseMath for uint256;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using P1BalanceMath for P1Types.Balance;\n    using P1IndexMath for P1Types.Index;\n    using SignedMath for SignedMath.Int;\n\n    // ============ Events ============\n\n    event LogIndex(\n        bytes32 index\n    );\n\n    event LogAccountSettled(\n        address indexed account,\n        bool isPositive,\n        uint256 amount,\n        bytes32 balance\n    );\n\n    // ============ Functions ============\n\n    /**\n     * @dev Calculates the funding change since the last update and stores it in the Global Index.\n     *\n     * @return Context struct that containing:\n     *         - The current oracle price;\n     *         - The global index;\n     *         - The minimum required collateralization.\n     */\n    function _loadContext()\n        internal\n        returns (P1Types.Context memory)\n    {\n        // SLOAD old index\n        P1Types.Index memory index = _GLOBAL_INDEX_;\n\n        // get Price (P)\n        uint256 price = I_P1Oracle(_ORACLE_).getPrice();\n\n        // get Funding (F)\n        uint256 timeDelta = block.timestamp.sub(index.timestamp);\n        if (timeDelta > 0) {\n            // turn the current index into a signed integer\n            SignedMath.Int memory signedIndex = SignedMath.Int({\n                value: index.value,\n                isPositive: index.isPositive\n            });\n\n            // Get the funding rate, applied over the time delta.\n            (\n                bool fundingPositive,\n                uint256 fundingValue\n            ) = I_P1Funder(_FUNDER_).getFunding(timeDelta);\n            fundingValue = fundingValue.baseMul(price);\n\n            // Update the index according to the funding rate, applied over the time delta.\n            if (fundingPositive) {\n                signedIndex = signedIndex.add(fundingValue);\n            } else {\n                signedIndex = signedIndex.sub(fundingValue);\n            }\n\n            // store new index\n            index = P1Types.Index({\n                timestamp: block.timestamp.toUint32(),\n                isPositive: signedIndex.isPositive,\n                value: signedIndex.value.toUint128()\n            });\n            _GLOBAL_INDEX_ = index;\n        }\n\n        emit LogIndex(index.toBytes32());\n\n        return P1Types.Context({\n            price: price,\n            minCollateral: _MIN_COLLATERAL_,\n            index: index\n        });\n    }\n\n    /**\n     * @dev Calculates the funding change since the last update and stores it in the Global Index.\n     *\n     * @return Context struct that containing:\n     *         - The current oracle price;\n     *         - The global index;\n     *         - The minimum required collateralization.\n     */\n    function _loadContextWithPrice(uint256 price)\n        internal\n        returns (P1Types.Context memory)\n    {\n        // SLOAD old index\n        P1Types.Index memory index = _GLOBAL_INDEX_;\n\n        // get Price (P)\n        // uint256 price = I_P1Oracle(_ORACLE_).getPrice();\n\n        // get Funding (F)\n        uint256 timeDelta = block.timestamp.sub(index.timestamp);\n        if (timeDelta > 0) {\n            // turn the current index into a signed integer\n            SignedMath.Int memory signedIndex = SignedMath.Int({\n                value: index.value,\n                isPositive: index.isPositive\n            });\n\n            // Get the funding rate, applied over the time delta.\n            (\n                bool fundingPositive,\n                uint256 fundingValue\n            ) = I_P1Funder(_FUNDER_).getFunding(timeDelta);\n            fundingValue = fundingValue.baseMul(price);\n\n            // Update the index according to the funding rate, applied over the time delta.\n            if (fundingPositive) {\n                signedIndex = signedIndex.add(fundingValue);\n            } else {\n                signedIndex = signedIndex.sub(fundingValue);\n            }\n\n            // store new index\n            index = P1Types.Index({\n                timestamp: block.timestamp.toUint32(),\n                isPositive: signedIndex.isPositive,\n                value: signedIndex.value.toUint128()\n            });\n            _GLOBAL_INDEX_ = index;\n        }\n\n        emit LogIndex(index.toBytes32());\n\n        return P1Types.Context({\n            price: price,\n            minCollateral: _MIN_COLLATERAL_,\n            index: index\n        });\n    }\n\n    /**\n     * @dev Settle the funding payments for a list of accounts and return their resulting balances.\n     */\n    function _settleAccounts(\n        P1Types.Context memory context,\n        address[] memory accounts,\n        uint256[] memory settlementAmounts,\n        bool[] memory settlementIsPositives\n    )\n        internal\n        returns (P1Types.Balance[] memory)\n    {\n        uint256 numAccounts = accounts.length;\n        P1Types.Balance[] memory result = new P1Types.Balance[](numAccounts);\n\n        for (uint256 i = 0; i < numAccounts; i++) {\n            result[i] = _settleAccount(context, accounts[i], settlementAmounts[i], settlementIsPositives[i]);\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Settle the funding payment for a single account and return its resulting balance.\n     */\n    function _settleAccount(\n        P1Types.Context memory context,\n        address account,\n        uint256 settlementAmount,\n        bool settlementIsPositive\n    )\n        internal\n        returns (P1Types.Balance memory)\n    {\n        P1Types.Index memory newIndex = context.index;\n        P1Types.Index memory oldIndex = _LOCAL_INDEXES_[account];\n        P1Types.Balance memory balance = _BALANCES_[account];\n\n        // Don't update the index if no time has passed.\n        if (oldIndex.timestamp == newIndex.timestamp) {\n            return balance;\n        }\n\n        // Store a cached copy of the index for this account.\n        _LOCAL_INDEXES_[account] = newIndex;\n\n        // No need for settlement if balance is zero.\n        if (balance.position == 0) {\n            return balance;\n        }\n\n        // // Get the difference between the newIndex and oldIndex.\n        // SignedMath.Int memory signedIndexDiff = SignedMath.Int({\n        //     isPositive: newIndex.isPositive,\n        //     value: newIndex.value\n        // });\n        // if (oldIndex.isPositive) {\n        //     signedIndexDiff = signedIndexDiff.sub(oldIndex.value);\n        // } else {\n        //     signedIndexDiff = signedIndexDiff.add(oldIndex.value);\n        // }\n\n        // By convention, positive funding (index increases) means longs pay shorts\n        // and negative funding (index decreases) means shorts pay longs.\n        // bool settlementIsPositive = signedIndexDiff.isPositive != balance.positionIsPositive;\n\n        // Settle the account balance by applying the index delta as a credit or debit.\n        // The interest amount scales with the position size.\n        //\n        // We round interest debits up and credits down to ensure that the contract won't become\n        // insolvent due to rounding errors.\n        // uint256 settlementAmount;\n        if (settlementIsPositive) {\n            // settlementAmount = signedIndexDiff.value.baseMul(balance.position);\n            balance.addToMargin(settlementAmount);\n        } else {\n            // settlementAmount = signedIndexDiff.value.baseMulRoundUp(balance.position);\n            balance.subFromMargin(settlementAmount);\n        }\n        _BALANCES_[account] = balance;\n\n        // Log the change to the account balance, which is the negative of the change in the index.\n        emit LogAccountSettled(\n            account,\n            settlementIsPositive,\n            settlementAmount,\n            balance.toBytes32()\n        );\n\n        return balance;\n    }\n\n        /**\n     * @dev Settle the funding payment for a single account and return its resulting balance.\n     */\n    function _settleAccountWhenUserForceWithdraw(\n        P1Types.Context memory context,\n        address account\n    )\n        internal\n        returns (P1Types.Balance memory, bool settlementIsPositive, uint256 settlementAmount)\n    {\n        P1Types.Index memory newIndex = context.index;\n        P1Types.Index memory oldIndex = _LOCAL_INDEXES_[account];\n        P1Types.Balance memory balance = _BALANCES_[account];\n\n        // Don't update the index if no time has passed.\n        if (oldIndex.timestamp == newIndex.timestamp) {\n            return (balance, false, 0);\n        }\n\n        // Store a cached copy of the index for this account.\n        _LOCAL_INDEXES_[account] = newIndex;\n\n        // No need for settlement if balance is zero.\n        if (balance.position == 0) {\n            return (balance, false, 0);\n        }\n\n        // Get the difference between the newIndex and oldIndex.\n        SignedMath.Int memory signedIndexDiff = SignedMath.Int({\n            isPositive: newIndex.isPositive,\n            value: newIndex.value\n        });\n        if (oldIndex.isPositive) {\n            signedIndexDiff = signedIndexDiff.sub(oldIndex.value);\n        } else {\n            signedIndexDiff = signedIndexDiff.add(oldIndex.value);\n        }\n\n        // By convention, positive funding (index increases) means longs pay shorts\n        // and negative funding (index decreases) means shorts pay longs.\n        settlementIsPositive = signedIndexDiff.isPositive != balance.positionIsPositive;\n\n        // Settle the account balance by applying the index delta as a credit or debit.\n        // The interest amount scales with the position size.\n        //\n        // We round interest debits up and credits down to ensure that the contract won't become\n        // insolvent due to rounding errors.\n        // settlementAmount;\n        if (settlementIsPositive) {\n            settlementAmount = signedIndexDiff.value.baseMul(balance.position);\n            balance.addToMargin(settlementAmount);\n        } else {\n            settlementAmount = signedIndexDiff.value.baseMulRoundUp(balance.position);\n            balance.subFromMargin(settlementAmount);\n        }\n        _BALANCES_[account] = balance;\n\n        // Log the change to the account balance, which is the negative of the change in the index.\n        emit LogAccountSettled(\n            account,\n            settlementIsPositive,\n            settlementAmount,\n            balance.toBytes32()\n        );\n\n        return (balance, settlementIsPositive, settlementAmount);\n    }\n\n    /**\n     * @dev Returns true if the balance is collateralized according to the price and minimum\n     * collateralization passed-in through the context.\n     */\n    function _isCollateralized(\n        P1Types.Context memory context,\n        P1Types.Balance memory balance\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        (uint256 positive, uint256 negative) = balance.getPositiveAndNegativeValue(context.price);\n\n        // Overflow risk assessment:\n        // 2^256 / 10^36 is significantly greater than 2^120 and this calculation is therefore not\n        // expected to be a limiting factor on the size of accounts that this contract can handle.\n        return positive.mul(BaseMath.base()) >= negative.mul(context.minCollateral);\n    }\n}\n"
    },
    "contracts/protocol/v1/impl/P1Storage.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { Adminable } from \"../../lib/Adminable.sol\";\nimport { ReentrancyGuard } from \"../../lib/ReentrancyGuard.sol\";\nimport { P1Types } from \"../lib/P1Types.sol\";\n\n\n/**\n * @title P1Storage\n * @author axor\n *\n * @notice Storage contract. Contains or inherits from all contracts that have ordered storage.\n */\ncontract P1Storage is\n    Adminable,\n    ReentrancyGuard\n{\n    mapping(address => P1Types.Balance) internal _BALANCES_;\n    mapping(address => P1Types.Index) internal _LOCAL_INDEXES_;\n\n    mapping(address => bool) internal _GLOBAL_OPERATORS_;\n    mapping(address => uint256) internal _WITHDRAW_DELAY_;\n    mapping(address => mapping(address => bool)) internal _LOCAL_OPERATORS_;\n\n    address internal _TOKEN_;\n    address internal _ORACLE_;\n    address internal _FUNDER_;\n\n    P1Types.Index internal _GLOBAL_INDEX_;\n    uint256 internal _MIN_COLLATERAL_;\n\n    bool internal _FINAL_SETTLEMENT_ENABLED_;\n    uint256 internal _FINAL_SETTLEMENT_PRICE_;\n    uint256 internal _WITHDRAW_DELAY_BLOCK_;\n}\n"
    },
    "contracts/protocol/v1/impl/P1Trade.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { P1FinalSettlement } from \"./P1FinalSettlement.sol\";\nimport { BaseMath } from \"../../lib/BaseMath.sol\";\nimport { Require } from \"../../lib/Require.sol\";\nimport { I_P1Trader } from \"../intf/I_P1Trader.sol\";\nimport { P1BalanceMath } from \"../lib/P1BalanceMath.sol\";\nimport { P1Types } from \"../lib/P1Types.sol\";\n\n\n/**\n * @title P1Trade\n * @author axor\n *\n * @notice Contract for settling trades between two accounts. A \"trade\" in this context may refer\n *  to any approved transfer of balances, as determined by the smart contracts implementing the\n *  I_P1Trader interface and approved as global operators on the PerpetualV1 contract.\n */\ncontract P1Trade is\n    P1FinalSettlement\n{\n    using SafeMath for uint120;\n    using P1BalanceMath for P1Types.Balance;\n\n    // ============ Structs ============\n\n    struct TradeArg {\n        uint256 takerIndex;\n        uint256 makerIndex;\n        address trader;\n        bytes data;\n    }\n\n    struct TradeArgWithPrice {\n        uint256 takerIndex;\n        uint256 makerIndex;\n        uint256 price;\n        address trader;\n        bytes data;\n    }\n\n    // ============ Events ============\n\n    event LogTrade(\n        address indexed maker,\n        address indexed taker,\n        address trader,\n        uint256 marginAmount,\n        uint256 positionAmount,\n        bool isBuy, // from taker's perspective\n        bytes32 makerBalance,\n        bytes32 takerBalance\n    );\n\n    // ============ Functions ============\n\n    /**\n     * @notice Submits one or more trades between any number of accounts.\n     * @dev Emits the LogIndex event, one LogAccountSettled event for each account in `accounts`,\n     *  and the LogTrade event for each trade in `trades`.\n     *\n     * @param  accounts  The sorted list of accounts that are involved in trades.\n     * @param  trades    The list of trades to execute in-order.\n     */\n    function trade(\n        address[] memory accounts,\n        TradeArg[] memory trades,\n        uint256[] memory settlementAmounts,\n        bool[] memory settlementIsPositives,\n        uint256 price // to update global index\n    )\n        public\n        noFinalSettlement\n        nonReentrant\n    {\n        require(\n            _GLOBAL_OPERATORS_[msg.sender],\n            \"trader is not global operator\"\n        );\n        _verifyAccounts(accounts);\n        P1Types.Context memory context = _loadContextWithPrice(price);\n        P1Types.Balance[] memory initialBalances = _settleAccounts(context, accounts, settlementAmounts, settlementIsPositives);\n        P1Types.Balance[] memory currentBalances = new P1Types.Balance[](initialBalances.length);\n\n        uint256 i;\n        for (i = 0; i < accounts.length; i++) {\n            _WITHDRAW_DELAY_[accounts[i]] = 0;\n        }\n        for (i = 0; i < initialBalances.length; i++) {\n            currentBalances[i] = initialBalances[i].copy();\n        }\n\n        bytes32 traderFlags = 0;\n        for (i = 0; i < trades.length; i++) {\n            TradeArg memory tradeArg = trades[i];\n\n            require(\n                _GLOBAL_OPERATORS_[tradeArg.trader],\n                \"trader is not global operator\"\n            );\n\n            address maker = accounts[tradeArg.makerIndex];\n            address taker = accounts[tradeArg.takerIndex];\n\n            P1Types.TradeResult memory tradeResult = I_P1Trader(tradeArg.trader).trade(\n                msg.sender,\n                maker,\n                taker,\n                context.price,\n                tradeArg.data,\n                traderFlags\n            );\n\n            traderFlags |= tradeResult.traderFlags;\n\n            // If the accounts are equal, no need to update balances.\n            if (maker == taker) {\n                continue;\n            }\n\n            // Modify currentBalances in-place. Note that `isBuy` is from the taker's perspective.\n            P1Types.Balance memory makerBalance = currentBalances[tradeArg.makerIndex];\n            P1Types.Balance memory takerBalance = currentBalances[tradeArg.takerIndex];\n            if (tradeResult.isBuy) {\n                makerBalance.addToMargin(tradeResult.marginAmount);\n                makerBalance.subFromPosition(tradeResult.positionAmount);\n                takerBalance.subFromMargin(tradeResult.marginAmount);\n                takerBalance.addToPosition(tradeResult.positionAmount);\n            } else {\n                makerBalance.subFromMargin(tradeResult.marginAmount);\n                makerBalance.addToPosition(tradeResult.positionAmount);\n                takerBalance.addToMargin(tradeResult.marginAmount);\n                takerBalance.subFromPosition(tradeResult.positionAmount);\n            }\n\n            // Store the new balances in storage.\n            _BALANCES_[maker] = makerBalance;\n            _BALANCES_[taker] = takerBalance;\n\n            // _verifyAccountFinalBalance(\n            //     context,\n            //     accounts[tradeArg.makerIndex],\n            //     initialBalances[tradeArg.makerIndex],\n            //     currentBalances[tradeArg.makerIndex]\n            // );\n            // _verifyAccountFinalBalance(\n            //     context,\n            //     accounts[tradeArg.takerIndex],\n            //     initialBalances[tradeArg.takerIndex],\n            //     currentBalances[tradeArg.takerIndex]\n            // );\n\n            emit LogTrade(\n                maker,\n                taker,\n                tradeArg.trader,\n                tradeResult.marginAmount,\n                tradeResult.positionAmount,\n                tradeResult.isBuy,\n                makerBalance.toBytes32(),\n                takerBalance.toBytes32()\n            );\n        }\n\n        // _verifyAccountsFinalBalances(\n        //     context,\n        //     accounts,\n        //     initialBalances,\n        //     currentBalances\n        // );\n    }\n\n    /**\n     * @dev Verify that `accounts` contains at least one address and that the contents are unique.\n     *  We verify uniqueness by requiring that the array is sorted.\n     */\n    function _verifyAccounts(\n        address[] memory accounts\n    )\n        private\n        pure\n    {\n        require(\n            accounts.length > 0,\n            \"Accounts must have non-zero length\"\n        );\n\n        // Check that accounts are unique\n        address prevAccount = accounts[0];\n        for (uint256 i = 1; i < accounts.length; i++) {\n            address account = accounts[i];\n            require(\n                account > prevAccount,\n                \"Accounts must be sorted and unique\"\n            );\n            prevAccount = account;\n        }\n    }\n\n    /**\n     * Verify that account balances at the end of the tx are allowable given the initial balances.\n     *\n     * We require that for every account, either:\n     * 1. The account meets the collateralization requirement; OR\n     * 2. All of the following are true:\n     *   a) The absolute value of the account position has not increased;\n     *   b) The sign of the account position has not flipped positive to negative or vice-versa.\n     *   c) The account's collateralization ratio has not worsened;\n     */\n    function _verifyAccountsFinalBalances(\n        P1Types.Context memory context,\n        address[] memory accounts,\n        P1Types.Balance[] memory initialBalances,\n        P1Types.Balance[] memory currentBalances\n    )\n        private\n        pure\n    {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            P1Types.Balance memory currentBalance = currentBalances[i];\n            (uint256 currentPos, uint256 currentNeg) =\n                currentBalance.getPositiveAndNegativeValue(context.price);\n\n            // See P1Settlement._isCollateralized().\n            bool isCollateralized =\n                currentPos.mul(BaseMath.base()) >= currentNeg.mul(context.minCollateral);\n\n            if (isCollateralized) {\n                continue;\n            }\n\n            address account = accounts[i];\n            P1Types.Balance memory initialBalance = initialBalances[i];\n            (uint256 initialPos, uint256 initialNeg) =\n                initialBalance.getPositiveAndNegativeValue(context.price);\n\n            Require.that(\n                currentPos != 0,\n                \"account is undercollateralized and has no positive value\",\n                account\n            );\n            Require.that(\n                currentBalance.position <= initialBalance.position,\n                \"account is undercollateralized and absolute position size increased\",\n                account\n            );\n\n            // Note that currentBalance.position can't be zero at this point since that would imply\n            // either currentPos is zero or the account is well-collateralized.\n\n            Require.that(\n                currentBalance.positionIsPositive == initialBalance.positionIsPositive,\n                \"account is undercollateralized and position changed signs\",\n                account\n            );\n            Require.that(\n                initialNeg != 0,\n                \"account is undercollateralized and was not previously\",\n                account\n            );\n\n            // Note that at this point:\n            //   Absolute position size must have decreased and not changed signs.\n            //   Initial margin/position must be one of -/-, -/+, or +/-.\n            //   Current margin/position must now be either -/+ or +/-.\n            //\n            // Which implies one of the following [intial] -> [current] configurations:\n            //   [-/-] -> [+/-]\n            //   [-/+] -> [-/+]\n            //   [+/-] -> [+/-]\n\n            // Check that collateralization increased.\n            // In the case of [-/-] initial, initialPos == 0 so the following will pass. Otherwise:\n            // at this point, either initialNeg and currentNeg represent the margin values, or\n            // initialPos and currentPos do. Since the margin is multiplied by the base value in\n            // getPositiveAndNegativeValue(), it is safe to use baseDivMul() to divide the margin\n            // without any rounding. This is important to avoid the possibility of overflow.\n            Require.that(\n                currentBalance.positionIsPositive\n                    ? currentNeg.baseDivMul(initialPos) <= initialNeg.baseDivMul(currentPos)\n                    : initialPos.baseDivMul(currentNeg) <= currentPos.baseDivMul(initialNeg),\n                \"account is undercollateralized and collateralization decreased\",\n                account\n            );\n        }\n    }\n\n\n    /**\n     * Verify that account balances at the end of the tx are allowable given the initial balances.\n     *\n     * We require that for every account, either:\n     * 1. The account meets the collateralization requirement; OR\n     * 2. All of the following are true:\n     *   a) The absolute value of the account position has not increased;\n     *   b) The sign of the account position has not flipped positive to negative or vice-versa.\n     *   c) The account's collateralization ratio has not worsened;\n     */\n    function _verifyAccountFinalBalance(\n        P1Types.Context memory context,\n        address account,\n        P1Types.Balance memory initialBalance,\n        P1Types.Balance memory currentBalance\n    )\n        private\n        pure\n    {\n        (uint256 currentPos, uint256 currentNeg) =\n            currentBalance.getPositiveAndNegativeValue(context.price);\n\n        // See P1Settlement._isCollateralized().\n        bool isCollateralized =\n            currentPos.mul(BaseMath.base()) >= currentNeg.mul(context.minCollateral);\n\n        if (isCollateralized) {\n            return;\n        }\n\n        (uint256 initialPos, uint256 initialNeg) =\n            initialBalance.getPositiveAndNegativeValue(context.price);\n\n        Require.that(\n            currentPos != 0,\n            \"account is undercollateralized and has no positive value\",\n            account\n        );\n        Require.that(\n            currentBalance.position <= initialBalance.position,\n            \"account is undercollateralized and absolute position size increased\",\n            account\n        );\n\n        // Note that currentBalance.position can't be zero at this point since that would imply\n        // either currentPos is zero or the account is well-collateralized.\n\n        Require.that(\n            currentBalance.positionIsPositive == initialBalance.positionIsPositive,\n            \"account is undercollateralized and position changed signs\",\n            account\n        );\n        Require.that(\n            initialNeg != 0,\n            \"account is undercollateralized and was not previously\",\n            account\n        );\n\n        // Note that at this point:\n        //   Absolute position size must have decreased and not changed signs.\n        //   Initial margin/position must be one of -/-, -/+, or +/-.\n        //   Current margin/position must now be either -/+ or +/-.\n        //\n        // Which implies one of the following [intial] -> [current] configurations:\n        //   [-/-] -> [+/-]\n        //   [-/+] -> [-/+]\n        //   [+/-] -> [+/-]\n\n        // Check that collateralization increased.\n        // In the case of [-/-] initial, initialPos == 0 so the following will pass. Otherwise:\n        // at this point, either initialNeg and currentNeg represent the margin values, or\n        // initialPos and currentPos do. Since the margin is multiplied by the base value in\n        // getPositiveAndNegativeValue(), it is safe to use baseDivMul() to divide the margin\n        // without any rounding. This is important to avoid the possibility of overflow.\n        Require.that(\n            currentBalance.positionIsPositive\n                ? currentNeg.baseDivMul(initialPos) <= initialNeg.baseDivMul(currentPos)\n                : initialPos.baseDivMul(currentNeg) <= currentPos.baseDivMul(initialNeg),\n            \"account is undercollateralized and collateralization decreased\",\n            account\n        );\n    }\n}\n"
    },
    "contracts/protocol/v1/intf/I_P1Funder.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\n\n/**\n * @title I_P1Funder\n * @author axor\n *\n * @notice Interface for an oracle providing the funding rate for a perpetual market.\n */\ninterface I_P1Funder {\n\n    /**\n     * @notice Calculates the signed funding amount that has accumulated over a period of time.\n     *\n     * @param  timeDelta  Number of seconds over which to calculate the accumulated funding amount.\n     * @return            True if the funding rate is positive, and false otherwise.\n     * @return            The funding amount as a unitless rate, represented as a fixed-point number\n     *                    with 18 decimals.\n     */\n    function getFunding(\n        uint256 timeDelta\n    )\n        external\n        view\n        returns (bool, uint256);\n}\n"
    },
    "contracts/protocol/v1/intf/I_P1Oracle.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\n\n/**\n * @title I_P1Oracle\n * @author axor\n *\n * @notice Interface that PerpetualV1 Price Oracles must implement.\n */\ninterface I_P1Oracle {\n\n    /**\n     * @notice Returns the price of the underlying asset relative to the margin token.\n     *\n     * @return The price as a fixed-point number with 18 decimals.\n     */\n    function getPrice()\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/protocol/v1/intf/I_P1Trader.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { P1Types } from \"../lib/P1Types.sol\";\n\n\n/**\n * @title I_P1Trader\n * @author axor\n *\n * @notice Interface that PerpetualV1 Traders must implement.\n */\ninterface I_P1Trader {\n\n    /**\n     * @notice Returns the result of the trade between the maker and the taker. Expected to be\n     *  called by PerpetualV1. Reverts if the trade is disallowed.\n     *\n     * @param  sender       The address that called the `trade()` function of PerpetualV1.\n     * @param  maker        The address of the passive maker account.\n     * @param  taker        The address of the active taker account.\n     * @param  price        The current oracle price of the underlying asset.\n     * @param  data         Arbitrary data passed in to the `trade()` function of PerpetualV1.\n     * @param  traderFlags  Any flags that have been set by other I_P1Trader contracts during the\n     *                      same call to the `trade()` function of PerpetualV1.\n     * @return              The result of the trade from the perspective of the taker.\n     */\n    function trade(\n        address sender,\n        address maker,\n        address taker,\n        uint256 price,\n        bytes calldata data,\n        bytes32 traderFlags\n    )\n        external\n        returns (P1Types.TradeResult memory);\n}\n"
    },
    "contracts/protocol/v1/intf/I_PerpetualV1.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { P1Types } from \"../lib/P1Types.sol\";\n\n\n/**\n * @title I_PerpetualV1\n * @author axor\n *\n * @notice Interface for PerpetualV1.\n */\ninterface I_PerpetualV1 {\n\n    // ============ Structs ============\n\n    struct TradeArg {\n        uint256 takerIndex;\n        uint256 makerIndex;\n        address trader;\n        bytes data;\n    }\n\n    // ============ State-Changing Functions ============\n\n    /**\n     * @notice Submits one or more trades between any number of accounts.\n     *\n     * @param  accounts  The sorted list of accounts that are involved in trades.\n     * @param  trades    The list of trades to execute in-order.\n     */\n    function trade(\n        address[] calldata accounts,\n        TradeArg[] calldata trades\n    )\n        external;\n\n    /**\n     * @notice Withdraw the number of margin tokens equal to the value of the account at the time\n     *  that final settlement occurred.\n     */\n    function withdrawFinalSettlement()\n        external;\n\n    /**\n     * @notice Deposit some amount of margin tokens from the msg.sender into an account.\n     *\n     * @param  account  The account for which to credit the deposit.\n     * @param  amount   the amount of tokens to deposit.\n     */\n    function deposit(\n        address account,\n        uint256 amount\n    )\n        external;\n\n    /**\n     * @notice Withdraw some amount of margin tokens from an account to a destination address.\n     *\n     * @param  account      The account for which to debit the withdrawal.\n     * @param  destination  The address to which the tokens are transferred.\n     * @param  amount       The amount of tokens to withdraw.\n     */\n    function withdraw(\n        address account,\n        address destination,\n        uint256 amount\n    )\n        external;\n\n    /**\n     * @notice Grants or revokes permission for another account to perform certain actions on behalf\n     *  of the sender.\n     *\n     * @param  operator  The account that is approved or disapproved.\n     * @param  approved  True for approval, false for disapproval.\n     */\n    function setLocalOperator(\n        address operator,\n        bool approved\n    )\n        external;\n\n    // ============ Account Getters ============\n\n    /**\n     * @notice Get the balance of an account, without accounting for changes in the index.\n     *\n     * @param  account  The address of the account to query the balances of.\n     * @return          The balances of the account.\n     */\n    function getAccountBalance(\n        address account\n    )\n        external\n        view\n        returns (P1Types.Balance memory);\n\n    /**\n     * @notice Gets the most recently cached index of an account.\n     *\n     * @param  account  The address of the account to query the index of.\n     * @return          The index of the account.\n     */\n    function getAccountIndex(\n        address account\n    )\n        external\n        view\n        returns (P1Types.Index memory);\n\n    /**\n     * @notice Gets the local operator status of an operator for a particular account.\n     *\n     * @param  account   The account to query the operator for.\n     * @param  operator  The address of the operator to query the status of.\n     * @return           True if the operator is a local operator of the account, false otherwise.\n     */\n    function getIsLocalOperator(\n        address account,\n        address operator\n    )\n        external\n        view\n        returns (bool);\n\n    // ============ Global Getters ============\n\n    /**\n     * @notice Gets the global operator status of an address.\n     *\n     * @param  operator  The address of the operator to query the status of.\n     * @return           True if the address is a global operator, false otherwise.\n     */\n    function getIsGlobalOperator(\n        address operator\n    )\n        external\n        view\n        returns (bool);\n\n    /**\n     * @notice Gets the address of the ERC20 margin contract used for margin deposits.\n     *\n     * @return The address of the ERC20 token.\n     */\n    function getTokenContract()\n        external\n        view\n        returns (address);\n\n    /**\n     * @notice Gets the current address of the price oracle contract.\n     *\n     * @return The address of the price oracle contract.\n     */\n    function getOracleContract()\n        external\n        view\n        returns (address);\n\n    /**\n     * @notice Gets the current address of the funder contract.\n     *\n     * @return The address of the funder contract.\n     */\n    function getFunderContract()\n        external\n        view\n        returns (address);\n\n    /**\n     * @notice Gets the most recently cached global index.\n     *\n     * @return The most recently cached global index.\n     */\n    function getGlobalIndex()\n        external\n        view\n        returns (P1Types.Index memory);\n\n    /**\n     * @notice Gets minimum collateralization ratio of the protocol.\n     *\n     * @return The minimum-acceptable collateralization ratio, returned as a fixed-point number with\n     *  18 decimals of precision.\n     */\n    function getMinCollateral()\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Gets the status of whether final-settlement was initiated by the Admin.\n     *\n     * @return True if final-settlement was enabled, false otherwise.\n     */\n    function getFinalSettlementEnabled()\n        external\n        view\n        returns (bool);\n\n    // ============ Public Getters ============\n\n    /**\n     * @notice Gets whether an address has permissions to operate an account.\n     *\n     * @param  account   The account to query.\n     * @param  operator  The address to query.\n     * @return           True if the operator has permission to operate the account,\n     *                   and false otherwise.\n     */\n    function hasAccountPermissions(\n        address account,\n        address operator\n    )\n        external\n        view\n        returns (bool);\n\n    // ============ Authorized Getters ============\n\n    /**\n     * @notice Gets the price returned by the oracle.\n     * @dev Only able to be called by global operators.\n     *\n     * @return The price returned by the current price oracle.\n     */\n    function getOraclePrice()\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/protocol/v1/lib/P1BalanceMath.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { P1Types } from \"./P1Types.sol\";\nimport { BaseMath } from \"../../lib/BaseMath.sol\";\nimport { SafeCast } from \"../../lib/SafeCast.sol\";\nimport { SignedMath } from \"../../lib/SignedMath.sol\";\n\n\n/**\n * @title P1BalanceMath\n * @author axor\n *\n * @dev Library for manipulating P1Types.Balance structs.\n */\nlibrary P1BalanceMath {\n    using BaseMath for uint256;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using SignedMath for SignedMath.Int;\n    using P1BalanceMath for P1Types.Balance;\n\n    // ============ Constants ============\n\n    uint256 private constant FLAG_MARGIN_IS_POSITIVE = 1 << (8 * 31);\n    uint256 private constant FLAG_POSITION_IS_POSITIVE = 1 << (8 * 15);\n\n    // ============ Functions ============\n\n    /**\n     * @dev Create a copy of the balance struct.\n     */\n    function copy(\n        P1Types.Balance memory balance\n    )\n        internal\n        pure\n        returns (P1Types.Balance memory)\n    {\n        return P1Types.Balance({\n            marginIsPositive: balance.marginIsPositive,\n            positionIsPositive: balance.positionIsPositive,\n            margin: balance.margin,\n            position: balance.position\n        });\n    }\n\n    /**\n     * @dev In-place add amount to balance.margin.\n     */\n    function addToMargin(\n        P1Types.Balance memory balance,\n        uint256 amount\n    )\n        internal\n        pure\n    {\n        SignedMath.Int memory signedMargin = balance.getMargin();\n        signedMargin = signedMargin.add(amount);\n        balance.setMargin(signedMargin);\n    }\n\n    /**\n     * @dev In-place subtract amount from balance.margin.\n     */\n    function subFromMargin(\n        P1Types.Balance memory balance,\n        uint256 amount\n    )\n        internal\n        pure\n    {\n        SignedMath.Int memory signedMargin = balance.getMargin();\n        signedMargin = signedMargin.sub(amount);\n        balance.setMargin(signedMargin);\n    }\n\n    /**\n     * @dev In-place add amount to balance.position.\n     */\n    function addToPosition(\n        P1Types.Balance memory balance,\n        uint256 amount\n    )\n        internal\n        pure\n    {\n        SignedMath.Int memory signedPosition = balance.getPosition();\n        signedPosition = signedPosition.add(amount);\n        balance.setPosition(signedPosition);\n    }\n\n    /**\n     * @dev In-place subtract amount from balance.position.\n     */\n    function subFromPosition(\n        P1Types.Balance memory balance,\n        uint256 amount\n    )\n        internal\n        pure\n    {\n        SignedMath.Int memory signedPosition = balance.getPosition();\n        signedPosition = signedPosition.sub(amount);\n        balance.setPosition(signedPosition);\n    }\n\n    /**\n     * @dev Returns the positive and negative values of the margin and position together, given a\n     *  price, which is used as a conversion rate between the two currencies.\n     *\n     *  No rounding occurs here--the returned values are \"base values\" with extra precision.\n     */\n    function getPositiveAndNegativeValue(\n        P1Types.Balance memory balance,\n        uint256 price\n    )\n        internal\n        pure\n        returns (uint256, uint256)\n    {\n        uint256 positiveValue = 0;\n        uint256 negativeValue = 0;\n\n        // add value of margin\n        if (balance.marginIsPositive) {\n            positiveValue = uint256(balance.margin).mul(BaseMath.base());\n        } else {\n            negativeValue = uint256(balance.margin).mul(BaseMath.base());\n        }\n\n        // add value of position\n        uint256 positionValue = uint256(balance.position).mul(price);\n        if (balance.positionIsPositive) {\n            positiveValue = positiveValue.add(positionValue);\n        } else {\n            negativeValue = negativeValue.add(positionValue);\n        }\n\n        return (positiveValue, negativeValue);\n    }\n\n    /**\n     * @dev Returns a compressed bytes32 representation of the balance for logging.\n     */\n    function toBytes32(\n        P1Types.Balance memory balance\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        uint256 result =\n            uint256(balance.position)\n            | (uint256(balance.margin) << 128)\n            | (balance.marginIsPositive ? FLAG_MARGIN_IS_POSITIVE : 0)\n            | (balance.positionIsPositive ? FLAG_POSITION_IS_POSITIVE : 0);\n        return bytes32(result);\n    }\n\n    // ============ Helper Functions ============\n\n    /**\n     * @dev Returns a SignedMath.Int version of the margin in balance.\n     */\n    function getMargin(\n        P1Types.Balance memory balance\n    )\n        internal\n        pure\n        returns (SignedMath.Int memory)\n    {\n        return SignedMath.Int({\n            value: balance.margin,\n            isPositive: balance.marginIsPositive\n        });\n    }\n\n    /**\n     * @dev Returns a SignedMath.Int version of the position in balance.\n     */\n    function getPosition(\n        P1Types.Balance memory balance\n    )\n        internal\n        pure\n        returns (SignedMath.Int memory)\n    {\n        return SignedMath.Int({\n            value: balance.position,\n            isPositive: balance.positionIsPositive\n        });\n    }\n\n    /**\n     * @dev In-place modify the signed margin value of a balance.\n     */\n    function setMargin(\n        P1Types.Balance memory balance,\n        SignedMath.Int memory newMargin\n    )\n        internal\n        pure\n    {\n        balance.margin = newMargin.value.toUint120();\n        balance.marginIsPositive = newMargin.isPositive;\n    }\n\n    /**\n     * @dev In-place modify the signed position value of a balance.\n     */\n    function setPosition(\n        P1Types.Balance memory balance,\n        SignedMath.Int memory newPosition\n    )\n        internal\n        pure\n    {\n        balance.position = newPosition.value.toUint120();\n        balance.positionIsPositive = newPosition.isPositive;\n    }\n}\n"
    },
    "contracts/protocol/v1/lib/P1IndexMath.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { P1Types } from \"./P1Types.sol\";\n\n\n/**\n * @title P1IndexMath\n * @author axor\n *\n * @dev Library for manipulating P1Types.Index structs.\n */\nlibrary P1IndexMath {\n\n    // ============ Constants ============\n\n    uint256 private constant FLAG_IS_POSITIVE = 1 << (8 * 16);\n\n    // ============ Functions ============\n\n    /**\n     * @dev Returns a compressed bytes32 representation of the index for logging.\n     */\n    function toBytes32(\n        P1Types.Index memory index\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        uint256 result =\n            index.value\n            | (index.isPositive ? FLAG_IS_POSITIVE : 0)\n            | (uint256(index.timestamp) << 136);\n        return bytes32(result);\n    }\n}\n"
    },
    "contracts/protocol/v1/lib/P1Types.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\n\n/**\n * @title P1Types\n * @author axor\n *\n * @dev Library for common types used in PerpetualV1 contracts.\n */\nlibrary P1Types {\n    // ============ Structs ============\n\n    /**\n     * @dev Used to represent the global index and each account's cached index.\n     *  Used to settle funding paymennts on a per-account basis.\n     */\n    struct Index {\n        uint32 timestamp;\n        bool isPositive;\n        uint128 value;\n    }\n\n    /**\n     * @dev Used to track the signed margin balance and position balance values for each account.\n     */\n    struct Balance {\n        bool marginIsPositive;\n        bool positionIsPositive;\n        uint120 margin;\n        uint120 position;\n    }\n\n    /**\n     * @dev Used to cache commonly-used variables that are relatively gas-intensive to obtain.\n     */\n    struct Context {\n        uint256 price;\n        uint256 minCollateral;\n        Index index;\n    }\n\n    /**\n     * @dev Used by contracts implementing the I_P1Trader interface to return the result of a trade.\n     */\n    struct TradeResult {\n        uint256 marginAmount;\n        uint256 positionAmount;\n        bool isBuy; // From taker's perspective.\n        bytes32 traderFlags;\n    }\n}\n"
    },
    "contracts/protocol/v1/oracles/P1ChainlinkOracle.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { I_Aggregator } from \"../../../external/chainlink/I_Aggregator.sol\";\nimport { BaseMath } from \"../../lib/BaseMath.sol\";\nimport { I_P1Oracle } from \"../intf/I_P1Oracle.sol\";\n\n\n/**\n * @title P1ChainlinkOracle\n * @author axor\n *\n * @notice P1Oracle that reads the price from a Chainlink aggregator.\n */\ncontract P1ChainlinkOracle is\n    I_P1Oracle\n{\n    using BaseMath for uint256;\n\n    // ============ Storage ============\n\n    // The underlying aggregator to get the price from.\n    address public _ORACLE_;\n\n    // The address with permission to read the oracle price.\n    address public _READER_;\n\n    // A constant factor to adjust the price by, as a fixed-point number with 18 decimal places.\n    uint256 public _ADJUSTMENT_;\n\n    // Compact storage for the above parameters.\n    mapping (address => bytes32) public _MAPPING_;\n\n    // ============ Constructor ============\n\n    constructor(\n        address oracle,\n        address reader,\n        uint96 adjustmentExponent\n    )\n        public\n    {\n        _ORACLE_ = oracle;\n        _READER_ = reader;\n        _ADJUSTMENT_ = 10 ** uint256(adjustmentExponent);\n\n        bytes32 oracleAndAdjustment =\n            bytes32(bytes20(oracle)) |\n            bytes32(uint256(adjustmentExponent));\n        _MAPPING_[reader] = oracleAndAdjustment;\n    }\n\n    // ============ Public Functions ============\n\n    /**\n     * @notice Returns the oracle price from the aggregator.\n     *\n     * @return The adjusted price as a fixed-point number with 18 decimals.\n     */\n    function getPrice()\n        external\n        view\n        returns (uint256)\n    {\n        bytes32 oracleAndExponent = _MAPPING_[msg.sender];\n        require(\n            oracleAndExponent != bytes32(0),\n            \"P1ChainlinkOracle: Sender not authorized to get price\"\n        );\n        (address oracle, uint256 adjustment) = getOracleAndAdjustment(oracleAndExponent);\n        int256 answer = I_Aggregator(oracle).latestAnswer();\n        require(\n            answer > 0,\n            \"P1ChainlinkOracle: Invalid answer from aggregator\"\n        );\n        uint256 rawPrice = uint256(answer);\n        return rawPrice.baseMul(adjustment);\n    }\n\n    function getOracleAndAdjustment(\n        bytes32 oracleAndExponent\n    )\n        private\n        pure\n        returns (address, uint256)\n    {\n        address oracle = address(bytes20(oracleAndExponent));\n        uint256 exponent = uint256(uint96(uint256(oracleAndExponent)));\n        return (oracle, 10 ** exponent);\n    }\n}\n"
    },
    "contracts/protocol/v1/oracles/P1FundingOracle.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport { BaseMath } from \"../../lib/BaseMath.sol\";\nimport { Math } from \"../../lib/Math.sol\";\nimport { SafeCast } from \"../../lib/SafeCast.sol\";\nimport { SignedMath } from \"../../lib/SignedMath.sol\";\nimport { I_P1Funder } from \"../intf/I_P1Funder.sol\";\nimport { P1IndexMath } from \"../lib/P1IndexMath.sol\";\nimport { P1Types } from \"../lib/P1Types.sol\";\n\n\n/**\n * @title P1FundingOracle\n * @author axor\n *\n * @notice Oracle providing the funding rate for a perpetual market.\n */\ncontract P1FundingOracle is\n    Ownable,\n    I_P1Funder\n{\n    using BaseMath for uint256;\n    using SafeCast for uint256;\n    using SafeMath for uint128;\n    using SafeMath for uint256;\n    using P1IndexMath for P1Types.Index;\n    using SignedMath for SignedMath.Int;\n\n    // ============ Constants ============\n\n    uint256 private constant FLAG_IS_POSITIVE = 1 << 128;\n    uint128 constant internal BASE = 10 ** 18;\n\n    /**\n     * @notice Bounding params constraining updates to the funding rate.\n     *\n     *  Like the funding rate, these are per-second rates, fixed-point with 18 decimals.\n     *  We calculate the per-second rates from the market specifications, which use 8-hour rates:\n     *  - The max absolute funding rate is 0.75% (8-hour rate).\n     *  - The max change over a 45-minute period is 1.5% (8-hour rate).\n     *\n     *  This means the fastest the funding rate can go from its min to its max value, or vice versa,\n     *  is in 45 minutes.\n     */\n    uint128 public constant MAX_ABS_VALUE = BASE * 75 / 10000 / (8 hours);\n    uint128 public constant MAX_ABS_DIFF_PER_SECOND = MAX_ABS_VALUE * 2 / (45 minutes);\n\n    // ============ Events ============\n\n    event LogFundingRateUpdated(\n        bytes32 fundingRate\n    );\n\n    event LogFundingRateProviderSet(\n        address fundingRateProvider\n    );\n\n    // ============ Mutable Storage ============\n\n    // The funding rate is denoted in units per second, as a fixed-point number with 18 decimals.\n    P1Types.Index private _FUNDING_RATE_;\n\n    // Address which has the ability to update the funding rate.\n    address public _FUNDING_RATE_PROVIDER_;\n\n    // ============ Constructor ============\n\n    constructor(\n        address fundingRateProvider\n    )\n        public\n    {\n        P1Types.Index memory fundingRate = P1Types.Index({\n            timestamp: block.timestamp.toUint32(),\n            isPositive: true,\n            value: 0\n        });\n        _FUNDING_RATE_ = fundingRate;\n        _FUNDING_RATE_PROVIDER_ = fundingRateProvider;\n\n        emit LogFundingRateUpdated(fundingRate.toBytes32());\n        emit LogFundingRateProviderSet(fundingRateProvider);\n    }\n\n    // ============ External Functions ============\n\n    /**\n     * @notice Set the funding rate, denoted in units per second, fixed-point with 18 decimals.\n     * @dev Can only be called by the funding rate provider. Emits the LogFundingRateUpdated event.\n     *\n     * @param  newRate  The intended new funding rate. Is bounded by the global constant bounds.\n     * @return          The new funding rate with a timestamp of the update.\n     */\n    function setFundingRate(\n        SignedMath.Int calldata newRate\n    )\n        external\n        returns (P1Types.Index memory)\n    {\n        require(\n            msg.sender == _FUNDING_RATE_PROVIDER_,\n            \"The funding rate can only be set by the funding rate provider\"\n        );\n\n        SignedMath.Int memory boundedNewRate = _boundRate(newRate);\n        P1Types.Index memory boundedNewRateWithTimestamp = P1Types.Index({\n            timestamp: block.timestamp.toUint32(),\n            isPositive: boundedNewRate.isPositive,\n            value: boundedNewRate.value.toUint128()\n        });\n        _FUNDING_RATE_ = boundedNewRateWithTimestamp;\n\n        emit LogFundingRateUpdated(boundedNewRateWithTimestamp.toBytes32());\n\n        return boundedNewRateWithTimestamp;\n    }\n\n    /**\n     * @notice Set the funding rate provider. Can only be called by the admin.\n     * @dev Emits the LogFundingRateProviderSet event.\n     *\n     * @param  newProvider  The new provider, who will have the ability to set the funding rate.\n     */\n    function setFundingRateProvider(\n        address newProvider\n    )\n        external\n        onlyOwner\n    {\n        _FUNDING_RATE_PROVIDER_ = newProvider;\n        emit LogFundingRateProviderSet(newProvider);\n    }\n\n    // ============ Public Functions ============\n\n    /**\n     * @notice Calculates the signed funding amount that has accumulated over a period of time.\n     *\n     * @param  timeDelta  Number of seconds over which to calculate the accumulated funding amount.\n     * @return            True if the funding rate is positive, and false otherwise.\n     * @return            The funding amount as a unitless rate, represented as a fixed-point number\n     *                    with 18 decimals.\n     */\n    function getFunding(\n        uint256 timeDelta\n    )\n        public\n        view\n        returns (bool, uint256)\n    {\n        // Note: Funding interest in PerpetualV1 does not compound, as the interest affects margin\n        // balances but is calculated based on position balances.\n        P1Types.Index memory fundingRate = _FUNDING_RATE_;\n        uint256 fundingAmount = uint256(fundingRate.value).mul(timeDelta);\n        return (fundingRate.isPositive, fundingAmount);\n    }\n\n    // ============ Helper Functions ============\n\n    /**\n     * @dev Apply the contract-defined bounds and return the bounded rate.\n     */\n    function _boundRate(\n        SignedMath.Int memory newRate\n    )\n        private\n        view\n        returns (SignedMath.Int memory)\n    {\n        // Get the old rate from storage.\n        P1Types.Index memory oldRateWithTimestamp = _FUNDING_RATE_;\n        SignedMath.Int memory oldRate = SignedMath.Int({\n            value: oldRateWithTimestamp.value,\n            isPositive: oldRateWithTimestamp.isPositive\n        });\n\n        // Get the maximum allowed change in the rate.\n        uint256 timeDelta = block.timestamp.sub(oldRateWithTimestamp.timestamp);\n        uint256 maxDiff = MAX_ABS_DIFF_PER_SECOND.mul(timeDelta);\n\n        // Calculate and return the bounded rate.\n        if (newRate.gt(oldRate)) {\n            SignedMath.Int memory upperBound = SignedMath.min(\n                oldRate.add(maxDiff),\n                SignedMath.Int({ value: MAX_ABS_VALUE, isPositive: true })\n            );\n            return SignedMath.min(\n                newRate,\n                upperBound\n            );\n        } else {\n            SignedMath.Int memory lowerBound = SignedMath.max(\n                oldRate.sub(maxDiff),\n                SignedMath.Int({ value: MAX_ABS_VALUE, isPositive: false })\n            );\n            return SignedMath.max(\n                newRate,\n                lowerBound\n            );\n        }\n    }\n}\n"
    },
    "contracts/protocol/v1/oracles/P1InverseFundingOracle.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { P1FundingOracle } from \"./P1FundingOracle.sol\";\n\n\n/**\n * @title P1InverseFundingOracle\n * @author axor\n *\n * @notice P1FundingOracle that uses the inverted rate (i.e. flips base and quote currencies)\n *  when getting the funding amount.\n */\ncontract P1InverseFundingOracle is\n    P1FundingOracle\n{\n    // ============ Constructor ============\n\n    constructor(\n        address fundingRateProvider\n    )\n        P1FundingOracle(fundingRateProvider)\n        public\n    {\n    }\n\n    // ============ External Functions ============\n\n    /**\n     * @notice Calculates the signed funding amount that has accumulated over a period of time.\n     *\n     * @param  timeDelta  Number of seconds over which to calculate the accumulated funding amount.\n     * @return            True if the funding rate is positive, and false otherwise.\n     * @return            The funding amount as a unitless rate, represented as a fixed-point number\n     *                    with 18 decimals.\n     */\n    function getFunding(\n        uint256 timeDelta\n    )\n        public\n        view\n        returns (bool, uint256)\n    {\n        (bool isPositive, uint256 fundingAmount) = super.getFunding(timeDelta);\n        return (!isPositive, fundingAmount);\n    }\n}\n"
    },
    "contracts/protocol/v1/oracles/P1MakerOracle.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { Ownable } from \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport { I_MakerOracle } from \"../../../external/maker/I_MakerOracle.sol\";\nimport { BaseMath } from \"../../lib/BaseMath.sol\";\nimport { I_P1Oracle } from \"../intf/I_P1Oracle.sol\";\n\n\n/**\n * @title P1MakerOracle\n * @author axor\n *\n * @notice P1Oracle that reads the price from a Maker V2 Oracle.\n */\ncontract P1MakerOracle is\n    Ownable,\n    I_P1Oracle\n{\n    using BaseMath for uint256;\n\n    // ============ Events ============\n\n    event LogRouteSet(\n        address indexed sender,\n        address oracle\n    );\n\n    event LogAdjustmentSet(\n        address indexed oracle,\n        uint256 adjustment\n    );\n\n    // ============ Storage ============\n\n    // @dev Maps from the sender to the oracle address to use.\n    mapping(address => address) public _ROUTER_;\n\n    // @dev The amount to adjust the price by. Is as a fixed-point number with 18 decimal places.\n    mapping(address => uint256) public _ADJUSTMENTS_;\n\n    // ============ Public Functions ============\n\n    /**\n     * @notice Returns the price of the underlying asset relative to the margin token.\n     *\n     * @return The price as a fixed-point number with 18 decimals.\n     */\n    function getPrice()\n        external\n        view\n        returns (uint256)\n    {\n        // get the oracle address to read from\n        address oracle = _ROUTER_[msg.sender];\n\n        // revert if no oracle found\n        require(\n            oracle != address(0),\n            \"Sender not authorized to get price\"\n        );\n\n        // get adjustment or default to 1\n        uint256 adjustment = _ADJUSTMENTS_[oracle];\n        if (adjustment == 0) {\n            adjustment = BaseMath.base();\n        }\n\n        // get the adjusted price\n        uint256 rawPrice = uint256(I_MakerOracle(oracle).read());\n        uint256 result = rawPrice.baseMul(adjustment);\n\n        // revert if invalid price\n        require(\n            result != 0,\n            \"Oracle would return zero price\"\n        );\n\n        return result;\n    }\n\n    // ============ Admin Functions ============\n\n    /**\n     * @dev Allows the owner to set a route for a particular sender.\n     *\n     * @param  sender The sender to set the route for.\n     * @param  oracle The oracle to route the sender to.\n     */\n    function setRoute(\n        address sender,\n        address oracle\n    )\n        external\n        onlyOwner\n    {\n        _ROUTER_[sender] = oracle;\n        emit LogRouteSet(sender, oracle);\n    }\n\n    /**\n     * @dev Allows the owner to set an adjustment to an oracle source.\n     *\n     * @param  oracle     The oracle to apply the adjustment to.\n     * @param  adjustment The adjustment to set when reading from the oracle.\n     */\n    function setAdjustment(\n        address oracle,\n        uint256 adjustment\n    )\n        external\n        onlyOwner\n    {\n        _ADJUSTMENTS_[oracle] = adjustment;\n        emit LogAdjustmentSet(oracle, adjustment);\n    }\n}\n"
    },
    "contracts/protocol/v1/PerpetualV1.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { Storage } from \"../lib/Storage.sol\";\nimport { P1Admin } from \"./impl/P1Admin.sol\";\nimport { P1FinalSettlement } from \"./impl/P1FinalSettlement.sol\";\nimport { P1Getters } from \"./impl/P1Getters.sol\";\nimport { P1Margin } from \"./impl/P1Margin.sol\";\nimport { P1Operator } from \"./impl/P1Operator.sol\";\nimport { P1Trade } from \"./impl/P1Trade.sol\";\nimport { P1Types } from \"./lib/P1Types.sol\";\n\n\n/**\n * @title PerpetualV1\n * @author axor\n *\n * @notice A market for a perpetual contract, a financial derivative which may be traded on margin\n *  and which aims to closely track the spot price of an underlying asset. The underlying asset is\n *  specified via the price oracle which reports its spot price. Tethering of the perpetual market\n *  price is supported by a funding oracle which governs funding payments between longs and shorts.\n * @dev Main perpetual market implementation contract that inherits from other contracts.\n */\ncontract PerpetualV1 is\n    P1FinalSettlement,\n    P1Admin,\n    P1Getters,\n    P1Margin,\n    P1Operator,\n    P1Trade\n{\n    // Non-colliding storage slot.\n    bytes32 internal constant PERPETUAL_V1_INITIALIZE_SLOT =\n    bytes32(uint256(keccak256(\"axor.PerpetualV1.initialize\")) - 1);\n\n    /**\n     * @dev Once-only initializer function that replaces the constructor since this contract is\n     *  proxied. Uses a non-colliding storage slot to store if this version has been initialized.\n     * @dev Can only be called once and can only be called by the admin of this contract.\n     *\n     * @param  token          The address of the token to use for margin-deposits.\n     * @param  oracle         The address of the price oracle contract.\n     * @param  funder         The address of the funder contract.\n     * @param  minCollateral  The minimum allowed initial collateralization percentage.\n     */\n    function initializeV1(\n        address token,\n        address oracle,\n        address funder,\n        uint256 minCollateral\n    )\n        external\n        onlyAdmin\n        nonReentrant\n    {\n        // only allow initialization once\n        require(\n            Storage.load(PERPETUAL_V1_INITIALIZE_SLOT) == 0x0,\n            \"PerpetualV1 already initialized\"\n        );\n        Storage.store(PERPETUAL_V1_INITIALIZE_SLOT, bytes32(uint256(1)));\n\n        _TOKEN_ = token;\n        _ORACLE_ = oracle;\n        _FUNDER_ = funder;\n        _MIN_COLLATERAL_ = minCollateral;\n\n        _GLOBAL_INDEX_ = P1Types.Index({\n            timestamp: uint32(block.timestamp),\n            isPositive: false,\n            value: 0\n        });\n    }\n}\n"
    },
    "contracts/protocol/v1/proxies/P1LiquidatorProxy.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/ownership/Ownable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport { BaseMath } from \"../../lib/BaseMath.sol\";\nimport { SignedMath } from \"../../lib/SignedMath.sol\";\nimport { I_PerpetualV1 } from \"../intf/I_PerpetualV1.sol\";\nimport { P1BalanceMath } from \"../lib/P1BalanceMath.sol\";\nimport { P1Types } from \"../lib/P1Types.sol\";\n\n\n/**\n * @title P1LiquidatorProxy\n * @author axor\n *\n * @notice Proxy contract for liquidating accounts. A fixed percentage of each liquidation is\n * directed to the insurance fund.\n */\ncontract P1LiquidatorProxy is\n    Ownable\n{\n    using BaseMath for uint256;\n    using SafeMath for uint256;\n    using SignedMath for SignedMath.Int;\n    using P1BalanceMath for P1Types.Balance;\n    using SafeERC20 for IERC20;\n\n    // ============ Events ============\n\n    event LogLiquidatorProxyUsed(\n        address indexed liquidatee,\n        address indexed liquidator,\n        bool isBuy,\n        uint256 liquidationAmount,\n        uint256 feeAmount\n    );\n\n    event LogInsuranceFundSet(\n        address insuranceFund\n    );\n\n    event LogInsuranceFeeSet(\n        uint256 insuranceFee\n    );\n\n    // ============ Immutable Storage ============\n\n    // Address of the perpetual contract.\n    address public _PERPETUAL_V1_;\n\n    // Address of the P1Liquidation contract.\n    address public _LIQUIDATION_;\n\n    // ============ Mutable Storage ============\n\n    // Address of the insurance fund.\n    address public _INSURANCE_FUND_;\n\n    // Proportion of liquidation profits that is directed to the insurance fund.\n    // This number is represented as a fixed-point number with 18 decimals.\n    uint256 public _INSURANCE_FEE_;\n\n    // ============ Constructor ============\n\n    constructor (\n        address perpetualV1,\n        address liquidator,\n        address insuranceFund,\n        uint256 insuranceFee\n    )\n        public\n    {\n        _PERPETUAL_V1_ = perpetualV1;\n        _LIQUIDATION_ = liquidator;\n        _INSURANCE_FUND_ = insuranceFund;\n        _INSURANCE_FEE_ = insuranceFee;\n\n        emit LogInsuranceFundSet(insuranceFund);\n        emit LogInsuranceFeeSet(insuranceFee);\n    }\n\n    // ============ External Functions ============\n\n    /**\n     * @notice Sets the maximum allowance on the perpetual contract. Must be called at least once.\n     * @dev Cannot be run in the constructor due to technical restrictions in Solidity.\n     */\n    function approveMaximumOnPerpetual()\n        external\n    {\n        address perpetual = _PERPETUAL_V1_;\n        IERC20 tokenContract = IERC20(I_PerpetualV1(perpetual).getTokenContract());\n\n        // safeApprove requires unsetting the allowance first.\n        tokenContract.safeApprove(perpetual, 0);\n\n        // Set the allowance to the highest possible value.\n        tokenContract.safeApprove(perpetual, uint256(-1));\n    }\n\n    /**\n     * @notice Allows an account below the minimum collateralization to be liquidated by another\n     *  account. This allows the account to be partially or fully subsumed by the liquidator.\n     *  A proportion of all liquidation profits is directed to the insurance fund.\n     * @dev Emits the LogLiquidatorProxyUsed event.\n     *\n     * @param  liquidatee   The account to liquidate.\n     * @param  liquidator   The account that performs the liquidation.\n     * @param  isBuy        True if the liquidatee has a long position, false otherwise.\n     * @param  maxPosition  Maximum position size that the liquidator will take post-liquidation.\n     * @return              The change in position.\n     */\n    function liquidate(\n        address liquidatee,\n        address liquidator,\n        bool isBuy,\n        SignedMath.Int calldata maxPosition\n    )\n        external\n        returns (uint256)\n    {\n        I_PerpetualV1 perpetual = I_PerpetualV1(_PERPETUAL_V1_);\n\n        // Verify that this account can liquidate for the liquidator.\n        require(\n            liquidator == msg.sender || perpetual.hasAccountPermissions(liquidator, msg.sender),\n            \"msg.sender cannot operate the liquidator account\"\n        );\n\n        // Settle the liquidator's account and get balances.\n        perpetual.deposit(liquidator, 0);\n        P1Types.Balance memory initialBalance = perpetual.getAccountBalance(liquidator);\n\n        // Get the maximum liquidatable amount.\n        SignedMath.Int memory maxPositionDelta = _getMaxPositionDelta(\n            initialBalance,\n            isBuy,\n            maxPosition\n        );\n\n        // Do the liquidation.\n        _doLiquidation(\n            perpetual,\n            liquidatee,\n            liquidator,\n            maxPositionDelta\n        );\n\n        // Get the balances of the liquidator.\n        P1Types.Balance memory currentBalance = perpetual.getAccountBalance(liquidator);\n\n        // Get the liquidated amount and fee amount.\n        (uint256 liqAmount, uint256 feeAmount) = _getLiquidatedAndFeeAmount(\n            perpetual,\n            initialBalance,\n            currentBalance\n        );\n\n        // Transfer fee from liquidator to insurance fund.\n        if (feeAmount > 0) {\n            perpetual.withdraw(liquidator, address(this), feeAmount);\n            perpetual.deposit(_INSURANCE_FUND_, feeAmount);\n        }\n\n        // Log the result.\n        emit LogLiquidatorProxyUsed(\n            liquidatee,\n            liquidator,\n            isBuy,\n            liqAmount,\n            feeAmount\n        );\n\n        return liqAmount;\n    }\n\n    // ============ Admin Functions ============\n\n    /**\n     * @dev Allows the owner to set the insurance fund address. Emits the LogInsuranceFundSet event.\n     *\n     * @param  insuranceFund  The address to set as the insurance fund.\n     */\n    function setInsuranceFund(\n        address insuranceFund\n    )\n        external\n        onlyOwner\n    {\n        _INSURANCE_FUND_ = insuranceFund;\n        emit LogInsuranceFundSet(insuranceFund);\n    }\n\n    /**\n     * @dev Allows the owner to set the insurance fee. Emits the LogInsuranceFeeSet event.\n     *\n     * @param  insuranceFee  The new fee as a fixed-point number with 18 decimal places. Max of 50%.\n     */\n    function setInsuranceFee(\n        uint256 insuranceFee\n    )\n        external\n        onlyOwner\n    {\n        require(\n            insuranceFee <= BaseMath.base().div(2),\n            \"insuranceFee cannot be greater than 50%\"\n        );\n        _INSURANCE_FEE_ = insuranceFee;\n        emit LogInsuranceFeeSet(insuranceFee);\n    }\n\n    // ============ Helper Functions ============\n\n    /**\n     * @dev Calculate (and verify) the maximum amount to liquidate based on the maxPosition input.\n     */\n    function _getMaxPositionDelta(\n        P1Types.Balance memory initialBalance,\n        bool isBuy,\n        SignedMath.Int memory maxPosition\n    )\n        private\n        pure\n        returns (SignedMath.Int memory)\n    {\n        SignedMath.Int memory result = maxPosition.signedSub(initialBalance.getPosition());\n\n        require(\n            result.isPositive == isBuy && result.value > 0,\n            \"Cannot liquidate if it would put liquidator past the specified maxPosition\"\n        );\n\n        return result;\n    }\n\n    /**\n     * @dev Perform the liquidation by constructing the correct arguments and sending it to the\n     * perpetual.\n     */\n    function _doLiquidation(\n        I_PerpetualV1 perpetual,\n        address liquidatee,\n        address liquidator,\n        SignedMath.Int memory maxPositionDelta\n    )\n        private\n    {\n        // Create accounts. Base protocol requires accounts to be sorted.\n        bool takerFirst = liquidator < liquidatee;\n        address[] memory accounts = new address[](2);\n        uint256 takerIndex = takerFirst ? 0 : 1;\n        uint256 makerIndex = takerFirst ? 1 : 0;\n        accounts[takerIndex] = liquidator;\n        accounts[makerIndex] = liquidatee;\n\n        // Create trade args.\n        I_PerpetualV1.TradeArg[] memory trades = new I_PerpetualV1.TradeArg[](1);\n        trades[0] = I_PerpetualV1.TradeArg({\n            takerIndex: takerIndex,\n            makerIndex: makerIndex,\n            trader: _LIQUIDATION_,\n            data: abi.encode(\n                maxPositionDelta.value,\n                maxPositionDelta.isPositive,\n                false // allOrNothing\n            )\n        });\n\n        // Do the liquidation.\n        perpetual.trade(accounts, trades);\n    }\n\n    /**\n     * @dev Calculate the liquidated amount and also the fee amount based on a percentage of the\n     * value of the repaid debt.\n     * @return  The position amount bought or sold.\n     * @return  The fee amount in margin token.\n     */\n    function _getLiquidatedAndFeeAmount(\n        I_PerpetualV1 perpetual,\n        P1Types.Balance memory initialBalance,\n        P1Types.Balance memory currentBalance\n    )\n        private\n        view\n        returns (uint256, uint256)\n    {\n        // Get the change in the position and margin of the liquidator.\n        SignedMath.Int memory deltaPosition =\n            currentBalance.getPosition().signedSub(initialBalance.getPosition());\n        SignedMath.Int memory deltaMargin =\n            currentBalance.getMargin().signedSub(initialBalance.getMargin());\n\n        // Get the change in the balances of the liquidator.\n        P1Types.Balance memory deltaBalance;\n        deltaBalance.setPosition(deltaPosition);\n        deltaBalance.setMargin(deltaMargin);\n\n        // Get the positive and negative value taken by the liquidator.\n        uint256 price = perpetual.getOraclePrice();\n        (uint256 posValue, uint256 negValue) = deltaBalance.getPositiveAndNegativeValue(price);\n\n        // Calculate the fee amount based on the liquidation profit.\n        uint256 feeAmount = posValue > negValue\n            ? posValue.sub(negValue).baseMul(_INSURANCE_FEE_).div(BaseMath.base())\n            : 0;\n\n        return (deltaPosition.value, feeAmount);\n    }\n}\n"
    },
    "contracts/protocol/v1/proxies/P1Proxy.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport { I_PerpetualV1 } from \"../intf/I_PerpetualV1.sol\";\nimport \"hardhat/console.sol\";\n\n\n/**\n * @title P1Proxy\n * @author axor\n *\n * @notice Base contract for proxy contracts, which can be used to provide additional functionality\n *  or restrictions when making calls to a Perpetual contract on behalf of a user.\n */\ncontract P1Proxy {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Sets the maximum allowance on the Perpetual contract. Must be called at least once\n     *  on a given Perpetual before deposits can be made.\n     * @dev Cannot be run in the constructor due to technical restrictions in Solidity.\n     */\n    function approveMaximumOnPerpetual(\n        address perpetual\n    )\n        external\n    {\n        console.log(\"===============================\");\n        console.log(I_PerpetualV1(perpetual).getTokenContract());\n        IERC20 tokenContract = IERC20(I_PerpetualV1(perpetual).getTokenContract());\n\n        // safeApprove requires unsetting the allowance first.\n        tokenContract.safeApprove(perpetual, 0);\n\n        // Set the allowance to the highest possible value.\n        tokenContract.safeApprove(perpetual, uint256(-1));\n    }\n}\n"
    },
    "contracts/protocol/v1/traders/P1Liquidation.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { P1TraderConstants } from \"./P1TraderConstants.sol\";\nimport { BaseMath } from \"../../lib/BaseMath.sol\";\nimport { Math } from \"../../lib/Math.sol\";\nimport { P1Getters } from \"../impl/P1Getters.sol\";\nimport { P1BalanceMath } from \"../lib/P1BalanceMath.sol\";\nimport { P1Types } from \"../lib/P1Types.sol\";\n\n\n/**\n * @title P1Liquidation\n * @author axor\n *\n * @notice Contract allowing accounts to be liquidated by other accounts.\n */\ncontract P1Liquidation is\n    P1TraderConstants\n{\n    using SafeMath for uint256;\n    using Math for uint256;\n    using P1BalanceMath for P1Types.Balance;\n\n    // ============ Structs ============\n\n    struct TradeData {\n        uint256 amount;\n        bool isBuy; // from taker's perspective\n        bool allOrNothing; // if true, will revert if maker's position is less than the amount\n    }\n\n    // ============ Events ============\n\n    event LogLiquidated(\n        address indexed maker,\n        address indexed taker,\n        uint256 amount,\n        bool isBuy, // from taker's perspective\n        uint256 oraclePrice\n    );\n\n    // ============ Immutable Storage ============\n\n    // address of the perpetual contract\n    address public _PERPETUAL_V1_;\n\n    // ============ Constructor ============\n\n    constructor (\n        address perpetualV1\n    )\n        public\n    {\n        _PERPETUAL_V1_ = perpetualV1;\n    }\n\n    // ============ External Functions ============\n\n    /**\n     * @notice Allows an account below the minimum collateralization to be liquidated by another\n     *  account. This allows the account to be partially or fully subsumed by the liquidator.\n     * @dev Emits the LogLiquidated event.\n     *\n     * @param  sender  The address that called the trade() function on PerpetualV1.\n     * @param  maker   The account to be liquidated.\n     * @param  taker   The account of the liquidator.\n     * @param  price   The current oracle price of the underlying asset.\n     * @param  data    A struct of type TradeData.\n     * @return         The amounts to be traded, and flags indicating that a liquidation occurred.\n     */\n    function trade(\n        address sender,\n        address maker,\n        address taker,\n        uint256 price,\n        bytes calldata data,\n        bytes32 /* traderFlags */\n    )\n        external\n        returns (P1Types.TradeResult memory)\n    {\n        address perpetual = _PERPETUAL_V1_;\n\n        require(\n            msg.sender == perpetual,\n            \"msg.sender must be PerpetualV1\"\n        );\n\n        require(\n            P1Getters(perpetual).getIsGlobalOperator(sender),\n            \"Sender is not a global operator\"\n        );\n\n        TradeData memory tradeData = abi.decode(data, (TradeData));\n        P1Types.Balance memory makerBalance = P1Getters(perpetual).getAccountBalance(maker);\n\n        _verifyTrade(\n            tradeData,\n            makerBalance,\n            perpetual,\n            price\n        );\n\n        // Bound the execution amount by the size of the maker position.\n        uint256 amount = Math.min(tradeData.amount, makerBalance.position);\n\n        // When partially liquidating the maker, maintain the same position/margin ratio.\n        // Ensure the collateralization of the maker does not decrease.\n        uint256 marginAmount;\n        if (tradeData.isBuy) {\n            marginAmount = uint256(makerBalance.margin).getFractionRoundUp(\n                amount,\n                makerBalance.position\n            );\n        } else {\n            marginAmount = uint256(makerBalance.margin).getFraction(amount, makerBalance.position);\n        }\n\n        emit LogLiquidated(\n            maker,\n            taker,\n            amount,\n            tradeData.isBuy,\n            price\n        );\n\n        return P1Types.TradeResult({\n            marginAmount: marginAmount,\n            positionAmount: amount,\n            isBuy: tradeData.isBuy,\n            traderFlags: TRADER_FLAG_LIQUIDATION\n        });\n    }\n\n    // ============ Helper Functions ============\n\n    function _verifyTrade(\n        TradeData memory tradeData,\n        P1Types.Balance memory makerBalance,\n        address perpetual,\n        uint256 price\n    )\n        private\n        view\n    {\n        require(\n            _isUndercollateralized(makerBalance, perpetual, price),\n            \"Cannot liquidate since maker is not undercollateralized\"\n        );\n        require(\n            !tradeData.allOrNothing || makerBalance.position >= tradeData.amount,\n            \"allOrNothing is set and maker position is less than amount\"\n        );\n        require(\n            tradeData.isBuy == makerBalance.positionIsPositive,\n            \"liquidation must not increase maker's position size\"\n        );\n\n        // Disallow liquidating in the edge case where both the position and margin are negative.\n        //\n        // This case is not handled correctly by P1Trade. If an account is in this situation, the\n        // margin should first be set to zero via a deposit, then the account should be deleveraged.\n        require(\n            makerBalance.marginIsPositive || makerBalance.margin == 0 ||\n                makerBalance.positionIsPositive || makerBalance.position == 0,\n            \"Cannot liquidate when maker position and margin are both negative\"\n        );\n    }\n\n    function _isUndercollateralized(\n        P1Types.Balance memory balance,\n        address perpetual,\n        uint256 price\n    )\n        private\n        view\n        returns (bool)\n    {\n        uint256 minCollateral = P1Getters(perpetual).getMinCollateral();\n        (uint256 positive, uint256 negative) = balance.getPositiveAndNegativeValue(price);\n\n        // See P1Settlement.sol for discussion of overflow risk.\n        return positive.mul(BaseMath.base()) < negative.mul(minCollateral);\n    }\n}\n"
    },
    "contracts/protocol/v1/traders/P1Orders.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { P1TraderConstants } from \"./P1TraderConstants.sol\";\nimport { BaseMath } from \"../../lib/BaseMath.sol\";\nimport { TypedSignature } from \"../../lib/TypedSignature.sol\";\nimport { P1Getters } from \"../impl/P1Getters.sol\";\nimport { P1Types } from \"../lib/P1Types.sol\";\n\n\n/**\n * @title P1Orders\n * @author axor\n *\n * @notice Contract allowing trading between accounts using cryptographically signed messages.\n */\ncontract P1Orders is\n    P1TraderConstants\n{\n    using BaseMath for uint256;\n    using SafeMath for uint256;\n\n    // ============ Constants ============\n\n    // EIP191 header for EIP712 prefix\n    bytes2 constant private EIP191_HEADER = 0x1901;\n\n    // EIP712 Domain Name value\n    string constant private EIP712_DOMAIN_NAME = \"P1Orders\";\n\n    // EIP712 Domain Version value\n    string constant private EIP712_DOMAIN_VERSION = \"1.0\";\n\n    // Hash of the EIP712 Domain Separator Schema\n    /* solium-disable-next-line indentation */\n    bytes32 constant private EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\n        \"EIP712Domain(\",\n        \"string name,\",\n        \"string version,\",\n        \"uint256 chainId,\",\n        \"address verifyingContract\",\n        \")\"\n    ));\n\n    // Hash of the EIP712 LimitOrder struct\n    /* solium-disable-next-line indentation */\n    bytes32 constant private EIP712_ORDER_STRUCT_SCHEMA_HASH = keccak256(abi.encodePacked(\n        \"Order(\",\n        \"bytes32 flags,\",\n        \"uint256 amount,\",\n        \"uint256 limitPrice,\",\n        \"uint256 triggerPrice,\",\n        \"uint256 limitFee,\",\n        \"address maker,\",\n        \"address taker,\",\n        \"uint256 expiration\",\n        \")\"\n    ));\n\n    // Bitmasks for the flags field\n    bytes32 constant FLAG_MASK_NULL = bytes32(uint256(0));\n    bytes32 constant FLAG_MASK_IS_BUY = bytes32(uint256(1));\n    bytes32 constant FLAG_MASK_IS_DECREASE_ONLY = bytes32(uint256(1 << 1));\n    bytes32 constant FLAG_MASK_IS_NEGATIVE_LIMIT_FEE = bytes32(uint256(1 << 2));\n\n    // ============ Enums ============\n\n    enum OrderStatus {\n        Open,\n        Approved,\n        Canceled\n    }\n\n    // ============ Structs ============\n\n    struct Order {\n        bytes32 flags;\n        uint256 amount;\n        uint256 limitPrice;\n        uint256 triggerPrice;\n        uint256 limitFee;\n        address maker;\n        address taker;\n        uint256 expiration;\n    }\n\n    struct Fill {\n        uint256 amount;\n        uint256 price;\n        uint256 fee;\n        bool isNegativeFee;\n    }\n\n    struct TradeData {\n        Order order;\n        Fill fill;\n        TypedSignature.Signature signature;\n    }\n\n    struct OrderQueryOutput {\n        OrderStatus status;\n        uint256 filledAmount;\n    }\n\n    // ============ Events ============\n\n    event LogOrderCanceled(\n        address indexed maker,\n        bytes32 orderHash\n    );\n\n    event LogOrderApproved(\n        address indexed maker,\n        bytes32 orderHash\n    );\n\n    event LogOrderFilled(\n        bytes32 orderHash,\n        bytes32 flags,\n        uint256 triggerPrice,\n        Fill fill\n    );\n\n    // ============ Immutable Storage ============\n\n    // address of the perpetual contract\n    address public _PERPETUAL_V1_;\n\n    // Hash of the EIP712 Domain Separator data\n    bytes32 public _EIP712_DOMAIN_HASH_;\n\n    // ============ Mutable Storage ============\n\n    // order hash => filled amount (in position amount)\n    mapping (bytes32 => uint256) public _FILLED_AMOUNT_;\n\n    // order hash => status\n    mapping (bytes32 => OrderStatus) public _STATUS_;\n\n    // ============ Constructor ============\n\n    constructor (\n        address perpetualV1,\n        uint256 chainId\n    )\n        public\n    {\n        _PERPETUAL_V1_ = perpetualV1;\n\n        /* solium-disable-next-line indentation */\n        _EIP712_DOMAIN_HASH_ = keccak256(abi.encode(\n            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n            keccak256(bytes(EIP712_DOMAIN_NAME)),\n            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n            chainId,\n            address(this)\n        ));\n    }\n\n    // ============ External Functions ============\n\n    /**\n     * @notice Allows an account to take an order cryptographically signed by a different account.\n     * @dev Emits the LogOrderFilled event.\n     *\n     * @param  sender  The address that called the trade() function on PerpetualV1.\n     * @param  maker   The maker of the order.\n     * @param  taker   The taker of the order.\n     * @param  price   The current oracle price of the underlying asset.\n     * @param  data    A struct of type TradeData.\n     * @return         The assets to be traded and traderFlags that indicate that a trade occurred.\n     */\n    function trade(\n        address sender,\n        address maker,\n        address taker,\n        uint256 price,\n        bytes calldata data,\n        bytes32 /* traderFlags */\n    )\n        external\n        returns (P1Types.TradeResult memory)\n    {\n        address perpetual = _PERPETUAL_V1_;\n\n        require(\n            msg.sender == perpetual,\n            \"msg.sender must be PerpetualV1\"\n        );\n\n        if (taker != sender) {\n            require(\n                P1Getters(perpetual).hasAccountPermissions(taker, sender),\n                \"Sender does not have permissions for the taker\"\n            );\n        }\n\n        TradeData memory tradeData = abi.decode(data, (TradeData));\n        bytes32 orderHash = _getOrderHash(tradeData.order);\n\n        // validations\n        _verifyOrderStateAndSignature(\n            tradeData,\n            orderHash\n        );\n        _verifyOrderRequest(\n            tradeData,\n            maker,\n            taker,\n            perpetual,\n            price\n        );\n\n        // set _FILLED_AMOUNT_\n        uint256 oldFilledAmount = _FILLED_AMOUNT_[orderHash];\n        uint256 newFilledAmount = oldFilledAmount.add(tradeData.fill.amount);\n        require(\n            newFilledAmount <= tradeData.order.amount,\n            \"Cannot overfill order\"\n        );\n        _FILLED_AMOUNT_[orderHash] = newFilledAmount;\n\n        emit LogOrderFilled(\n            orderHash,\n            tradeData.order.flags,\n            tradeData.order.triggerPrice,\n            tradeData.fill\n        );\n\n        // Order fee is denoted as a percentage of execution price.\n        // Convert into an amount per unit position.\n        uint256 fee = tradeData.fill.fee.baseMul(tradeData.fill.price);\n\n        // `isBuyOrder` is from the maker's perspective.\n        bool isBuyOrder = _isBuy(tradeData.order);\n        uint256 marginPerPosition = (isBuyOrder == tradeData.fill.isNegativeFee)\n            ? tradeData.fill.price.sub(fee)\n            : tradeData.fill.price.add(fee);\n\n        return P1Types.TradeResult({\n            marginAmount: tradeData.fill.amount.baseMul(marginPerPosition),\n            positionAmount: tradeData.fill.amount,\n            isBuy: !isBuyOrder,\n            traderFlags: TRADER_FLAG_ORDERS\n        });\n    }\n\n    /**\n     * @notice On-chain approves an order.\n     * @dev Emits the LogOrderApproved event.\n     *\n     * @param  order  The order that will be approved.\n     */\n    function approveOrder(\n        Order calldata order\n    )\n        external\n    {\n        require(\n            msg.sender == order.maker,\n            \"Order cannot be approved by non-maker\"\n        );\n        bytes32 orderHash = _getOrderHash(order);\n        require(\n            _STATUS_[orderHash] != OrderStatus.Canceled,\n            \"Canceled order cannot be approved\"\n        );\n        _STATUS_[orderHash] = OrderStatus.Approved;\n        emit LogOrderApproved(msg.sender, orderHash);\n    }\n\n    /**\n     * @notice On-chain cancels an order.\n     * @dev Emits the LogOrderCanceled event.\n     *\n     * @param  order  The order that will be permanently canceled.\n     */\n    function cancelOrder(\n        Order calldata order\n    )\n        external\n    {\n        require(\n            msg.sender == order.maker,\n            \"Order cannot be canceled by non-maker\"\n        );\n        bytes32 orderHash = _getOrderHash(order);\n        _STATUS_[orderHash] = OrderStatus.Canceled;\n        emit LogOrderCanceled(msg.sender, orderHash);\n    }\n\n    // ============ Getter Functions ============\n\n    /**\n     * @notice Gets the status (open/approved/canceled) and filled amount of each order in a list.\n     *\n     * @param  orderHashes  A list of the hashes of the orders to check.\n     * @return              A list of OrderQueryOutput structs containing the status and filled\n     *                      amount of each order.\n     */\n    function getOrdersStatus(\n        bytes32[] calldata orderHashes\n    )\n        external\n        view\n        returns (OrderQueryOutput[] memory)\n    {\n        OrderQueryOutput[] memory result = new OrderQueryOutput[](orderHashes.length);\n        for (uint256 i = 0; i < orderHashes.length; i++) {\n            bytes32 orderHash = orderHashes[i];\n            result[i] = OrderQueryOutput({\n                status: _STATUS_[orderHash],\n                filledAmount: _FILLED_AMOUNT_[orderHash]\n            });\n        }\n        return result;\n    }\n\n    // ============ Helper Functions ============\n\n    function _verifyOrderStateAndSignature(\n        TradeData memory tradeData,\n        bytes32 orderHash\n    )\n        private\n        view\n    {\n        OrderStatus orderStatus = _STATUS_[orderHash];\n\n        if (orderStatus == OrderStatus.Open) {\n            require(\n                tradeData.order.maker == TypedSignature.recover(orderHash, tradeData.signature),\n                \"Order has an invalid signature\"\n            );\n        } else {\n            require(\n                orderStatus != OrderStatus.Canceled,\n                \"Order was already canceled\"\n            );\n            assert(orderStatus == OrderStatus.Approved);\n        }\n    }\n\n    function _verifyOrderRequest(\n        TradeData memory tradeData,\n        address maker,\n        address taker,\n        address perpetual,\n        uint256 price\n    )\n        private\n        view\n    {\n        require(\n            tradeData.order.maker == maker,\n            \"Order maker does not match maker\"\n        );\n        require(\n            tradeData.order.taker == taker || tradeData.order.taker == address(0),\n            \"Order taker does not match taker\"\n        );\n        require(\n            tradeData.order.expiration >= block.timestamp || tradeData.order.expiration == 0,\n            \"Order has expired\"\n        );\n\n        // `isBuyOrder` is from the maker's perspective.\n        bool isBuyOrder = _isBuy(tradeData.order);\n        bool validPrice = isBuyOrder\n            ? tradeData.fill.price <= tradeData.order.limitPrice\n            : tradeData.fill.price >= tradeData.order.limitPrice;\n        require(\n            validPrice,\n            \"Fill price is invalid\"\n        );\n\n        bool validFee = _isNegativeLimitFee(tradeData.order)\n            ? tradeData.fill.isNegativeFee && tradeData.fill.fee >= tradeData.order.limitFee\n            : tradeData.fill.isNegativeFee || tradeData.fill.fee <= tradeData.order.limitFee;\n        require(\n            validFee,\n            \"Fill fee is invalid\"\n        );\n\n        if (tradeData.order.triggerPrice != 0) {\n            bool validTriggerPrice = isBuyOrder\n                ? tradeData.order.triggerPrice <= price\n                : tradeData.order.triggerPrice >= price;\n            require(\n                validTriggerPrice,\n                \"Trigger price has not been reached\"\n            );\n        }\n\n        if (_isDecreaseOnly(tradeData.order)) {\n            P1Types.Balance memory balance = P1Getters(perpetual).getAccountBalance(maker);\n            require(\n                isBuyOrder != balance.positionIsPositive\n                && tradeData.fill.amount <= balance.position,\n                \"Fill does not decrease position\"\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the EIP712 hash of an order.\n     */\n    function _getOrderHash(\n        Order memory order\n    )\n        private\n        view\n        returns (bytes32)\n    {\n        // compute the overall signed struct hash\n        /* solium-disable-next-line indentation */\n        bytes32 structHash = keccak256(abi.encode(\n            EIP712_ORDER_STRUCT_SCHEMA_HASH,\n            order\n        ));\n\n        // compute eip712 compliant hash\n        /* solium-disable-next-line indentation */\n        return keccak256(abi.encodePacked(\n            EIP191_HEADER,\n            _EIP712_DOMAIN_HASH_,\n            structHash\n        ));\n    }\n\n    function _isBuy(\n        Order memory order\n    )\n        private\n        pure\n        returns (bool)\n    {\n        return (order.flags & FLAG_MASK_IS_BUY) != FLAG_MASK_NULL;\n    }\n\n    function _isDecreaseOnly(\n        Order memory order\n    )\n        private\n        pure\n        returns (bool)\n    {\n        return (order.flags & FLAG_MASK_IS_DECREASE_ONLY) != FLAG_MASK_NULL;\n    }\n\n    function _isNegativeLimitFee(\n        Order memory order\n    )\n        private\n        pure\n        returns (bool)\n    {\n        return (order.flags & FLAG_MASK_IS_NEGATIVE_LIMIT_FEE) != FLAG_MASK_NULL;\n    }\n}\n"
    },
    "contracts/protocol/v1/traders/P1TraderConstants.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\n\n/**\n * @title P1TraderConstants\n * @author axor\n *\n * @notice Constants for traderFlags set by contracts implementing the I_P1Trader interface.\n */\ncontract P1TraderConstants {\n    bytes32 constant internal TRADER_FLAG_ORDERS = bytes32(uint256(1));\n    bytes32 constant internal TRADER_FLAG_LIQUIDATION = bytes32(uint256(2));\n    bytes32 constant internal TRADER_FLAG_DELEVERAGING = bytes32(uint256(4));\n}\n"
    },
    "contracts/test/external/Test_ChainlinkAggregator.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { I_Aggregator } from \"../../external/chainlink/I_Aggregator.sol\";\n\n\n/**\n * @title Test_ChainlinkAggregator\n * @author axor\n *\n * Chainlink Aggregator for testing\n */\n/* solium-disable-next-line camelcase */\ncontract Test_ChainlinkAggregator is\n    I_Aggregator\n{\n    int256 public _ANSWER_ = 0;\n\n    // ============ Test Data Setter Functions ============\n\n    function setAnswer(\n        int256 newAnswer\n    )\n        external\n    {\n        _ANSWER_ = newAnswer;\n    }\n\n    // ============ Getter Functions ============\n\n    function latestAnswer()\n        external\n        view\n        returns (int256)\n    {\n        return _ANSWER_;\n    }\n}\n"
    },
    "contracts/test/external/Test_MakerOracle.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { I_MakerOracle } from \"../../external/maker/I_MakerOracle.sol\";\n\n\n/**\n * @title Test_MakerOracle\n * @author axor\n *\n * MakerOracle for testing\n */\n/* solium-disable-next-line camelcase */\ncontract Test_MakerOracle is\n    I_MakerOracle\n{\n    uint256 public bar = 1;\n    uint32 public age = uint32(block.timestamp);\n    mapping (address => uint256) public orcl;\n    mapping (address => uint256) public bud;\n    mapping (uint8 => address) public slot;\n    uint256 public _PRICE_ = 0;\n    bool public _VALID_ = true;\n\n    // ============ Set Functions ============\n\n    function setBar(\n        uint256 newBar\n    )\n        external\n    {\n        bar = newBar;\n    }\n\n    function setAge(\n        uint256 newAge\n    )\n        external\n    {\n        age = uint32(newAge);\n    }\n\n    function setPrice(\n        uint256 newPrice\n    )\n        external\n    {\n        _PRICE_ = newPrice;\n    }\n\n    function setValidity(\n        bool valid\n    )\n        external\n    {\n        _VALID_ = valid;\n    }\n\n    // ============ Getter Functions ============\n\n    function read()\n        external\n        view\n        returns (bytes32)\n    {\n        require(\n            _VALID_,\n            \"Median/invalid-price-feed\"\n        );\n        return bytes32(_PRICE_);\n    }\n\n    function peek()\n        external\n        view\n        returns (bytes32, bool)\n    {\n        return (bytes32(_PRICE_), _VALID_);\n    }\n\n    // ============ State-Changing Functions ============\n\n    function poke(\n        uint256[] calldata,\n        uint256[] calldata,\n        uint8[] calldata,\n        bytes32[] calldata,\n        bytes32[] calldata\n    )\n        external\n    { /* solium-disable-line no-empty-blocks */ }\n\n    function lift(\n        address[] calldata signers\n    )\n        external\n    {\n        for (uint i = 0; i < signers.length; i++) {\n            address signer = signers[i];\n            uint8 signerId = uint8(uint256(signer) >> 152);\n            orcl[signer] = 1;\n            slot[signerId] = signer;\n        }\n    }\n\n    function drop(\n        address[] calldata signers\n    )\n        external\n    {\n        for (uint i = 0; i < signers.length; i++) {\n            address signer = signers[i];\n            uint8 signerId = uint8(uint256(signer) >> 152);\n            orcl[signer] = 0;\n            slot[signerId] = address(0);\n        }\n    }\n\n    function kiss(\n        address reader\n    )\n        external\n    {\n        bud[reader] = 1;\n    }\n\n    function diss(\n        address reader\n    )\n        external\n    {\n        bud[reader] = 0;\n    }\n\n    function kiss(\n        address[] calldata readers\n    )\n        external\n    {\n        for (uint256 i = 0; i < readers.length; i++) {\n            bud[readers[i]] = 1;\n        }\n    }\n\n    function diss(\n        address[] calldata readers\n    )\n        external\n    {\n        for (uint256 i = 0; i < readers.length; i++) {\n            bud[readers[i]] = 0;\n        }\n    }\n}\n"
    },
    "contracts/test/Test_Lib.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { BaseMath } from \"../protocol/lib/BaseMath.sol\";\nimport { Math } from \"../protocol/lib/Math.sol\";\nimport { ReentrancyGuard } from \"../protocol/lib/ReentrancyGuard.sol\";\nimport { Require } from \"../protocol/lib/Require.sol\";\nimport { SafeCast } from \"../protocol/lib/SafeCast.sol\";\nimport { SignedMath } from \"../protocol/lib/SignedMath.sol\";\nimport { Storage } from \"../protocol/lib/Storage.sol\";\nimport { TypedSignature } from \"../protocol/lib/TypedSignature.sol\";\nimport { P1BalanceMath } from \"../protocol/v1/lib/P1BalanceMath.sol\";\nimport { P1Types } from \"../protocol/v1/lib/P1Types.sol\";\n\n\n/**\n * @title Test_Lib\n * @author axor\n *\n * @notice Exposes library functions for testing.\n */\n/* solium-disable-next-line camelcase */\ncontract Test_Lib is\n    ReentrancyGuard\n{\n\n    // ============ BaseMath.sol ============\n\n    function base()\n        external\n        pure\n        returns (uint256)\n    {\n        return BaseMath.base();\n    }\n\n    function baseMul(\n        uint256 value,\n        uint256 baseValue\n    )\n        external\n        pure\n        returns (uint256)\n    {\n        return BaseMath.baseMul(value, baseValue);\n    }\n\n    function baseDivMul(\n        uint256 value,\n        uint256 baseValue\n    )\n        external\n        pure\n        returns (uint256)\n    {\n        return BaseMath.baseDivMul(value, baseValue);\n    }\n\n    function baseMulRoundUp(\n        uint256 value,\n        uint256 baseValue\n    )\n        external\n        pure\n        returns (uint256)\n    {\n        return BaseMath.baseMulRoundUp(value, baseValue);\n    }\n\n    function baseDiv(\n        uint256 value,\n        uint256 baseValue\n    )\n        external\n        pure\n        returns (uint256)\n    {\n        return BaseMath.baseDiv(value, baseValue);\n    }\n\n    function baseReciprocal(\n        uint256 baseValue\n    )\n        external\n        pure\n        returns (uint256)\n    {\n        return BaseMath.baseReciprocal(baseValue);\n    }\n\n    // ============ Math.sol ============\n\n    function getFraction(\n        uint256 target,\n        uint256 numerator,\n        uint256 denominator\n    )\n        external\n        pure\n        returns (uint256)\n    {\n        return Math.getFraction(target, numerator, denominator);\n    }\n\n    function getFractionRoundUp(\n        uint256 target,\n        uint256 numerator,\n        uint256 denominator\n    )\n        external\n        pure\n        returns (uint256)\n    {\n        return Math.getFractionRoundUp(target, numerator, denominator);\n    }\n\n    function min(\n        uint256 a,\n        uint256 b\n    )\n        external\n        pure\n        returns (uint256)\n    {\n        return Math.min(a, b);\n    }\n\n    function max(\n        uint256 a,\n        uint256 b\n    )\n        external\n        pure\n        returns (uint256)\n    {\n        return Math.max(a, b);\n    }\n\n    // ============ Require.sol ============\n\n    function that(\n        bool must,\n        string calldata requireReason,\n        address addr\n    )\n        external\n        pure\n    {\n        Require.that(\n            must,\n            requireReason,\n            addr\n        );\n    }\n\n    // ============ SafeCast.sol ============\n\n    function toUint128(\n        uint256 value\n    )\n        external\n        pure\n        returns (uint128)\n    {\n        return SafeCast.toUint128(value);\n    }\n\n    function toUint120(\n        uint256 value\n    )\n        external\n        pure\n        returns (uint120)\n    {\n        return SafeCast.toUint120(value);\n    }\n\n    function toUint32(\n        uint256 value\n    )\n        external\n        pure\n        returns (uint32)\n    {\n        return SafeCast.toUint32(value);\n    }\n\n    // ============ SignedMath.sol ============\n\n    function add(\n        SignedMath.Int calldata sint,\n        uint256 value\n    )\n        external\n        pure\n        returns (SignedMath.Int memory)\n    {\n        return SignedMath.add(sint, value);\n    }\n\n    function sub(\n        SignedMath.Int calldata sint,\n        uint256 value\n    )\n        external\n        pure\n        returns (SignedMath.Int memory)\n    {\n        return SignedMath.sub(sint, value);\n    }\n\n    function signedAdd(\n        SignedMath.Int calldata augend,\n        SignedMath.Int calldata addend\n    )\n        external\n        pure\n        returns (SignedMath.Int memory)\n    {\n        return SignedMath.signedAdd(augend, addend);\n    }\n\n    function signedSub(\n        SignedMath.Int calldata minuend,\n        SignedMath.Int calldata subtrahend\n    )\n        external\n        pure\n        returns (SignedMath.Int memory)\n    {\n        return SignedMath.signedSub(minuend, subtrahend);\n    }\n\n    // ============ Storage.sol ============\n\n    function load(\n        bytes32 slot\n    )\n        external\n        view\n        returns (bytes32)\n    {\n        return Storage.load(slot);\n    }\n\n    function store(\n        bytes32 slot,\n        bytes32 value\n    )\n        external\n    {\n        Storage.store(slot, value);\n    }\n\n    // ============ TypedSignature.sol ============\n\n    function recover(\n        bytes32 hash,\n        bytes calldata signatureBytes\n    )\n        external\n        pure\n        returns (address)\n    {\n        TypedSignature.Signature memory signature = abi.decode(\n            signatureBytes,\n            (TypedSignature.Signature)\n        );\n        return TypedSignature.recover(hash, signature);\n    }\n\n    // ============ P1BalanceMath.sol ============\n\n    function copy(\n        P1Types.Balance calldata balance\n    )\n        external\n        pure\n        returns (P1Types.Balance memory)\n    {\n        return P1BalanceMath.copy(balance);\n    }\n\n    function addToMargin(\n        P1Types.Balance calldata balance,\n        uint256 amount\n    )\n        external\n        pure\n        returns (P1Types.Balance memory)\n    {\n        // Copy to memory, modify in place, and return the memory object.\n        P1Types.Balance memory _balance = balance;\n        P1BalanceMath.addToMargin(_balance, amount);\n        return _balance;\n    }\n\n    function subFromMargin(\n        P1Types.Balance calldata balance,\n        uint256 amount\n    )\n        external\n        pure\n        returns (P1Types.Balance memory)\n    {\n        // Copy to memory, modify in place, and return the memory object.\n        P1Types.Balance memory _balance = balance;\n        P1BalanceMath.subFromMargin(_balance, amount);\n        return _balance;\n    }\n\n    function addToPosition(\n        P1Types.Balance calldata balance,\n        uint256 amount\n    )\n        external\n        pure\n        returns (P1Types.Balance memory)\n    {\n        // Copy to memory, modify in place, and return the memory object.\n        P1Types.Balance memory _balance = balance;\n        P1BalanceMath.addToPosition(_balance, amount);\n        return _balance;\n    }\n\n    function subFromPosition(\n        P1Types.Balance calldata balance,\n        uint256 amount\n    )\n        external\n        pure\n        returns (P1Types.Balance memory)\n    {\n        // Copy to memory, modify in place, and return the memory object.\n        P1Types.Balance memory _balance = balance;\n        P1BalanceMath.subFromPosition(_balance, amount);\n        return _balance;\n    }\n\n    function getPositiveAndNegativeValue(\n        P1Types.Balance calldata balance,\n        uint256 price\n    )\n        external\n        pure\n        returns (uint256, uint256)\n    {\n        return P1BalanceMath.getPositiveAndNegativeValue(balance, price);\n    }\n\n    function getMargin(\n        P1Types.Balance calldata balance\n    )\n        external\n        pure\n        returns (SignedMath.Int memory)\n    {\n        return P1BalanceMath.getMargin(balance);\n    }\n\n    function getPosition(\n        P1Types.Balance calldata balance\n    )\n        external\n        pure\n        returns (SignedMath.Int memory)\n    {\n        return P1BalanceMath.getPosition(balance);\n    }\n\n    function setMargin(\n        P1Types.Balance calldata balance,\n        SignedMath.Int calldata newMargin\n    )\n        external\n        pure\n        returns (P1Types.Balance memory)\n    {\n        // Copy to memory, modify in place, and return the memory object.\n        P1Types.Balance memory _balance = balance;\n        P1BalanceMath.setMargin(_balance, newMargin);\n        return _balance;\n    }\n\n    function setPosition(\n        P1Types.Balance calldata balance,\n        SignedMath.Int calldata newPosition\n    )\n        external\n        pure\n        returns (P1Types.Balance memory)\n    {\n        // Copy to memory, modify in place, and return the memory object.\n        P1Types.Balance memory _balance = balance;\n        P1BalanceMath.setPosition(_balance, newPosition);\n        return _balance;\n    }\n\n    // ============ ReentrancyGuard.sol ============\n\n    function nonReentrant1()\n        public\n        nonReentrant\n        returns (uint256)\n    {\n        return this.nonReentrant2();\n    }\n\n    function nonReentrant2()\n        public\n        nonReentrant\n        returns (uint256)\n    {\n        return 0;\n    }\n}\n"
    },
    "contracts/test/Test_Token.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ERC20Detailed } from \"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\";\n\n\n/**\n * @title Test_Token\n * @author axor\n *\n * @notice ERC-20 token for testing\n */\n/* solium-disable-next-line camelcase */\ncontract Test_Token is\n    ERC20,\n    ERC20Detailed(\"Test Token\", \"TEST\", 6)\n{\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n    }\n}\n"
    },
    "contracts/test/Test_Token2.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ERC20Detailed } from \"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\";\n\n\n/**\n * @title Test_Token2\n * @author axor\n *\n * @notice A second ERC-20 token for testing.\n */\n/* solium-disable-next-line camelcase */\ncontract Test_Token2 is\n    ERC20,\n    ERC20Detailed(\"Test Token 2\", \"TEST2\", 6)\n{\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n    }\n}\n"
    },
    "contracts/test/v1/Test_P1Funder.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { I_P1Funder } from \"../../protocol/v1/intf/I_P1Funder.sol\";\n\n\n/**\n * @title Test_P1Funder\n * @author axor\n *\n * @notice I_P1Funder implementation for testing.\n */\n/* solium-disable-next-line camelcase */\ncontract Test_P1Funder is\n    I_P1Funder\n{\n    bool public _FUNDING_IS_POSITIVE_ = true;\n    uint256 public _FUNDING_ = 0;\n\n    function getFunding(\n        uint256 // timeDelta\n    )\n        external\n        view\n        returns (bool, uint256)\n    {\n        return (_FUNDING_IS_POSITIVE_, _FUNDING_);\n    }\n\n    function setFunding(\n        bool isPositive,\n        uint256 newFunding\n    )\n        external\n    {\n        _FUNDING_IS_POSITIVE_ = isPositive;\n        _FUNDING_ = newFunding;\n    }\n}\n"
    },
    "contracts/test/v1/Test_P1Monolith.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { Test_P1Funder } from \"./Test_P1Funder.sol\";\nimport { Test_P1Oracle } from \"./Test_P1Oracle.sol\";\nimport { Test_P1Trader } from \"./Test_P1Trader.sol\";\n\n\n/**\n * @title Test_P1Monolith\n * @author axor\n *\n * @notice A second contract for testing the funder, oracle, and trader.\n */\n/* solium-disable-next-line camelcase, no-empty-blocks */\ncontract Test_P1Monolith is\n    Test_P1Funder,\n    Test_P1Oracle,\n    Test_P1Trader\n{}\n"
    },
    "contracts/test/v1/Test_P1Oracle.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { I_P1Oracle } from \"../../protocol/v1/intf/I_P1Oracle.sol\";\n\n\n/**\n * @title Test_P1Oracle\n * @author axor\n *\n * @notice I_P1Oracle implementation for testing.\n */\n/* solium-disable-next-line camelcase */\ncontract Test_P1Oracle is\n    I_P1Oracle\n{\n    uint256 public _PRICE_ = 0;\n\n    function getPrice()\n        external\n        view\n        returns (uint256)\n    {\n        return _PRICE_;\n    }\n\n    function setPrice(\n        uint256 newPrice\n    )\n        external\n    {\n        _PRICE_ = newPrice;\n    }\n}\n"
    },
    "contracts/test/v1/Test_P1Trader.sol": {
      "content": "/*\n\n    Copyright 2024 Axor DAO\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport { I_P1Trader } from \"../../protocol/v1/intf/I_P1Trader.sol\";\nimport { P1Types } from \"../../protocol/v1/lib/P1Types.sol\";\n\n\n/**\n * @title Test_P1Trader\n * @author axor\n *\n * @notice I_P1Trader implementation for testing.\n */\n/* solium-disable-next-line camelcase */\ncontract Test_P1Trader is\n    I_P1Trader\n{\n    P1Types.TradeResult public _TRADE_RESULT_;\n    P1Types.TradeResult public _TRADE_RESULT_2_;\n\n    // Special testing-only trader flag that will cause the second result to be returned.\n    bytes32 constant public TRADER_FLAG_RESULT_2 = bytes32(~uint256(0));\n\n    function trade(\n        address, // sender\n        address, // maker\n        address, // taker\n        uint256, // price\n        bytes calldata, // data\n        bytes32 traderFlags\n    )\n        external\n        returns (P1Types.TradeResult memory)\n    {\n        if (traderFlags == TRADER_FLAG_RESULT_2) {\n            return _TRADE_RESULT_2_;\n        }\n        return _TRADE_RESULT_;\n    }\n\n    function setTradeResult(\n        uint256 marginAmount,\n        uint256 positionAmount,\n        bool isBuy,\n        bytes32 traderFlags\n    )\n        external\n    {\n        _TRADE_RESULT_ = P1Types.TradeResult({\n            marginAmount: marginAmount,\n            positionAmount: positionAmount,\n            isBuy: isBuy,\n            traderFlags: traderFlags\n        });\n    }\n\n    /**\n     * Sets a second trade result which can be triggered by the trader flags of the first trade.\n     */\n    function setSecondTradeResult(\n        uint256 marginAmount,\n        uint256 positionAmount,\n        bool isBuy,\n        bytes32 traderFlags\n    )\n        external\n    {\n        _TRADE_RESULT_2_ = P1Types.TradeResult({\n            marginAmount: marginAmount,\n            positionAmount: positionAmount,\n            isBuy: isBuy,\n            traderFlags: traderFlags\n        });\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}